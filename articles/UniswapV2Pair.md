---
title: "[Bunzz Decipher] UniswapV2Pairã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ç†è§£ã—ã‚ˆã†ï¼"
emoji: "ðŸ¦„"
type: "tech"
topics:
  - "blockchain"
  - "ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³"
  - "solidity"
  - "ethereum"
  - "defi"
published: true
published_at: "2023-08-10 07:43"
publication_name: "cryptogames"
---

# ã¯ã˜ã‚ã«

åˆã‚ã¾ã—ã¦ã€‚
**CryptoGames**ã¨ã„ã†ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚²ãƒ¼ãƒ ä¼æ¥­ã§ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã‚’ã—ã¦ã„ã‚‹ **cardeneï¼ˆã‹ã‚‹ã§ã­ï¼‰** ã§ã™ï¼
ã‚¹ãƒžãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’æ›¸ã„ãŸã‚Šã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ»ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ»ã‚¤ãƒ³ãƒ•ãƒ©ã¨å¹…åºƒãè§¦ã‚Œã¦ã„ã¾ã™ã€‚

https://cryptogames.co.jp/

ä»£è¡¨çš„ãªã‚²ãƒ¼ãƒ ã¯**ã‚¯ãƒªãƒ—ãƒˆã‚¹ãƒšãƒ«ã‚º**ã¨ã„ã†ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚²ãƒ¼ãƒ ã§ã™ã€‚

https://cryptospells.jp/

ä»Šå›žã¯Bunzzã®æ–°æ©Ÿèƒ½ã€Ž**DeCipher**ã€ã‚’ä½¿ç”¨ã—ã¦ã€UniswapV2ã®ã€Œ**UniswapV2Pair**ã€ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’è¦‹ã¦ã¿ã‚ˆã†ã¨æ€ã„ã¾ã™ã€‚

ã€Ž**DeCipher**ã€ã¯AIã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’è‡ªå‹•ç”Ÿæˆã—ã¦ãã‚Œã‚‹ã‚µãƒ¼ãƒ“ã‚¹ã§ã™ã€‚

https://www.bunzz.dev/decipher

è©³ã—ã„ä½¿ã„æ–¹ã«é–¢ã—ã¦ã¯ä»¥ä¸‹ã®è¨˜äº‹ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ï¼

https://zenn.dev/heku/articles/33266f0c19d523

:::message
ã“ã®è¨˜äº‹ã¯ã‚ãã¾ã§å€‹äººãŒã€Œ**DeCipher**ã€ã‚’ä½¿ç”¨ã—ã¦ã¿ã¦ã®è¨˜äº‹ã«ãªã‚Šã¾ã™ã€‚
é–“é•ã£ãŸéƒ¨åˆ†ãªã©ã‚‚ã‚ã‚‹ã‹ã¨æ€ã„ã¾ã™ãŒã€ãã®éš›ã¯ã‚³ãƒ¡ãƒ³ãƒˆãªã©ã§æ•™ãˆã¦ãã ã•ã„ã€‚
:::

ä»Šå›žä½¿ç”¨ã™ã‚‹ã€Ž**DeCipher**ã€ã®ãƒªãƒ³ã‚¯ã¯ä»¥ä¸‹ã«ãªã‚Šã¾ã™ã€‚

https://app.bunzz.dev/decipher/chains/1/addresses/0xA478c2975Ab1Ea89e8196811F51A7B7Ade33eB11

# æ¦‚è¦

## è¦ç´„

**UniswapV2Pair**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€Ethereumãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ä¸Šã«æ§‹ç¯‰ã•ã‚ŒãŸåˆ†æ•£åž‹å–å¼•æ‰€ **Uniswap**ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®é‡è¦ãªä¸€éƒ¨ã§ã™ã€‚
ã“ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€ä¸€å¯¾ã®**ERC20**ãƒˆãƒ¼ã‚¯ãƒ³ã®å–å¼•ã‚’ç®¡ç†ãŠã‚ˆã³å®Ÿè¡Œã™ã‚‹å½¹å‰²ã‚’æ‹…ã£ã¦ã„ã¾ã™ã€‚
**Uniswap V2**ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ä¸­æ ¸ã‚’æˆã™éƒ¨åˆ†ã§ã‚ã‚Šã€å…±é€šã®åŸºè»¸é€šè²¨ã‚’å¿…è¦ã¨ã›ãšã«ä»»æ„ã®äºŒã¤ã® **ERC20**ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¼•ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚

## ç›®çš„
**UniswapV2Pair**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ä¸»ãªç›®çš„ã¯ã€ç‰¹å®šã®ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã®æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã‚’ç®¡ç†ã™ã‚‹ã“ã¨ã§ã™ã€‚
ã“ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯æµå‹•æ€§ã®è¿½åŠ ã‚„å‰Šé™¤ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¹ãƒ¯ãƒƒãƒ—ã‚’å‡¦ç†ã—ã¾ã™ã€‚
ã¾ãŸã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã®ä¾¡æ ¼ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«ã€å„ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒªã‚¶ãƒ¼ãƒ–ï¼ˆä¿æœ‰é‡ï¼‰ã‚’è¿½è·¡ã—ã¾ã™ã€‚

## ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®è²¬ä»»
**UniswapV2Pair**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«ã¯ã„ãã¤ã‹ã®ä¸»è¦ãªè²¬ä»»ãŒã‚ã‚Šã¾ã™ã€‚

### ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†
ã“ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€`token0`ãŠã‚ˆã³`token1`ã¨å‘¼ã°ã‚Œã‚‹ä¸€å¯¾ã®**ERC20**ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç®¡ç†ã—ã¾ã™ã€‚
ã“ã‚Œã‚‰ã®ãƒˆãƒ¼ã‚¯ãƒ³ã¯ã€Ethereumãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ä¸Šã«å­˜åœ¨ã™ã‚‹ä»»æ„ã®**ERC20**ãƒˆãƒ¼ã‚¯ãƒ³ã§ã™ã€‚

### ãƒªã‚¶ãƒ¼ãƒ–ç®¡ç†
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã®ä¸¡æ–¹ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒªã‚¶ãƒ¼ãƒ–ï¼ˆä¿æœ‰é‡ï¼‰ã‚’è¨˜éŒ²ã—ã¾ã™ã€‚
ã“ã‚Œã‚‰ã®ãƒªã‚¶ãƒ¼ãƒ–ã¯å–å¼•ã‚’å®Ÿè¡Œã—ã€ä¾¡æ ¼ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
ãƒªã‚¶ãƒ¼ãƒ–ã¯ã€`reserve0`ã¨`reserve1`ã¨ã„ã†ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆå¤‰æ•°ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚

### ä¾¡æ ¼ã®è¨ˆç®—
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€å„ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒªã‚¶ãƒ¼ãƒ–ã«åŸºã¥ã„ã¦ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã®ä¾¡æ ¼ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
ã¾ãŸã€ç´¯ç©ä¾¡æ ¼å¤‰æ•°ï¼ˆ`price0CumulativeLast`ãŠã‚ˆã³`price1CumulativeLast`ï¼‰ã‚’ç¶­æŒã—ã€ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã®æ™‚é–“åŠ é‡å¹³å‡ä¾¡æ ¼ï¼ˆ**TWAP**ï¼‰ã®è¨ˆç®—ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

### æµå‹•æ€§ã‚¤ãƒ™ãƒ³ãƒˆ
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯`kLast`å¤‰æ•°ã‚’è¿½è·¡ã—ã¾ã™ã€‚
ã“ã‚Œã¯ã€æœ€æ–°ã®æµå‹•æ€§ã‚¤ãƒ™ãƒ³ãƒˆæ™‚ç‚¹ã§ã®ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã®ãƒªã‚¶ãƒ¼ãƒ–ã®ç©ã‚’è¡¨ã—ã¾ã™ã€‚
ã“ã‚Œã¯æµå‹•æ€§ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã®æ‰‹æ•°æ–™ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

### ãƒ­ãƒƒã‚¯æ©Ÿæ§‹
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«ã¯å†å…¥æ”»æ’ƒã‚’é˜²ããŸã‚ã®ãƒ­ãƒƒã‚¯æ©Ÿæ§‹ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
ã“ã‚Œã¯ã€`unlocked`å¤‰æ•°ã¨`lock`ãƒ¢ãƒ‡ã‚£ãƒ•ã‚¡ã‚¤ã‚¢ã‚’é€šã˜ã¦å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚

### æ‰¿èªã¨è»¢é€
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®æ‰¿èªã¨è»¢é€ã‚’è¡Œã†ãŸã‚ã®é–¢æ•°ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
ã“ã‚Œã‚‰ã®é–¢æ•°ï¼ˆ`approve`ã€`transfer`ã€`transferFrom`ï¼‰ã¯ã€**ERC20**ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¨™æº–çš„ãªæ©Ÿèƒ½ã§ã‚ã‚Šã€ã‚¢ãƒ‰ãƒ¬ã‚¹é–“ã§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç§»å‹•ã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

### åŒæœŸ
`sync`é–¢æ•°ã¯ã€å–å¼•ã¾ãŸã¯æµå‹•æ€§ã‚¤ãƒ™ãƒ³ãƒˆã®å¾Œã«ãƒªã‚¶ãƒ¼ãƒ–ã¨ä¾¡æ ¼ã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

### åˆæœŸåŒ–
`initialize`é–¢æ•°ã¯ã€ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆãŒæœ€åˆã«ä½œæˆã•ã‚ŒãŸã¨ãã«ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨­å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

ã¾ã¨ã‚ã‚‹ã¨ã€**UniswapV2Pair**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯**Uniswap**ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®åŸºæœ¬çš„ãªéƒ¨åˆ†ã§ã™ã€‚
ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã®ãƒªã‚¶ãƒ¼ãƒ–ã¨ä¾¡æ ¼ã‚’ç®¡ç†ã—ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®å–å¼•ã¨ç§»å‹•ã‚’å®¹æ˜“ã«ã—ã¾ã™ã€‚
ã“ã‚Œã¯åˆ†æ•£åž‹å–å¼•æ‰€ã®å‹•ä½œã«ãŠã„ã¦é‡è¦ãªå½¹å‰²ã‚’æžœãŸã™ã€è¤‡é›‘ãªã‚¹ãƒžãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ä¸€éƒ¨ã§ã™ã€‚

# ä½¿ã„æ–¹

**UniswapV2Pair**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€Ethereumãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ä¸Šã®åˆ†æ•£åž‹å–å¼•æ‰€**Uniswap**ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ä¸­æ ¸ã‚’ãªã™éƒ¨åˆ†ã§ã™ã€‚
ã“ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€äºŒã¤ã®ç•°ãªã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã‚’ç®¡ç†ã—ã€ãã‚Œã‚‰ã®ãƒˆãƒ¼ã‚¯ãƒ³é–“ã§ã®ã‚¹ãƒ¯ãƒƒãƒ—ã‚’å®¹æ˜“ã«ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

ä»¥ä¸‹ã« UniswapV2Pair ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ä½¿ç”¨æ‰‹é †ã‚’ã‚¹ãƒ†ãƒƒãƒ—ãƒã‚¤ã‚¹ãƒ†ãƒƒãƒ—ã§èª¬æ˜Žã—ã¾ã™ã€‚

### 1. ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã®ä½œæˆ

æœ€åˆã®ã‚¹ãƒ†ãƒƒãƒ—ã¯ã€æµå‹•æ€§ã‚’æä¾›ã—ãŸã‚Šã‚¹ãƒ¯ãƒƒãƒ—ã—ãŸã„ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒšã‚¢ã‚’ä½œæˆã™ã‚‹ã“ã¨ã§ã™ã€‚
ã“ã‚Œã¯ã€**IUniswapV2Factory**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®`createPair`é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§è¡Œã„ã¾ã™ã€‚
ã“ã®é–¢æ•°ã«ã¯äºŒã¤ã®å¼•æ•°ãŒå¿…è¦ã§ã€ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã‚’ä½œæˆã—ãŸã„äºŒã¤ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ¸¡ã—ã¾ã™ã€‚

### 2. æµå‹•æ€§ã®è¿½åŠ 

ãƒšã‚¢ã‚’ä½œæˆã—ãŸå¾Œã€å„ãƒˆãƒ¼ã‚¯ãƒ³ã®ä¸€å®šé‡ã‚’ãƒšã‚¢ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«é€ä¿¡ã™ã‚‹ã“ã¨ã§æµå‹•æ€§ã‚’è¿½åŠ ã§ãã¾ã™ã€‚ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«é€ä¿¡ã™ã‚‹ãŸã‚ã«ã¯ã€`transfer`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

### 3. ãƒšã‚¢ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®æ‰¿èª

ãƒšã‚¢ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¨ã®å¯¾è©±ã‚’é–‹å§‹ã™ã‚‹å‰ã«ã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ã†ãŸã‚ã«ãƒšã‚¢ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«å¯¾ã—ã¦æ‰¿èªãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚
ã“ã‚Œã¯ã€å„ãƒˆãƒ¼ã‚¯ãƒ³ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®`approve`é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§è¡Œã„ã¾ã™ã€‚
ãƒšã‚¢ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨æ‰¿èªã—ãŸã„é‡‘é¡ã‚’æ¸¡ã—ã¾ã™ã€‚

### 4. ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¹ãƒ¯ãƒƒãƒ—

ãƒšã‚¢ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆãŒæ‰¿èªã•ã‚Œã‚‹ã¨ã€`swap`é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ã‚¹ãƒ¯ãƒƒãƒ—ã§ãã¾ã™ã€‚
ã“ã®é–¢æ•°ã«ã¯ä»¥ä¸‹ã®å››ã¤ã®å¼•æ•°ãŒå¿…è¦ã§ã™ã€‚
- ã‚¹ãƒ¯ãƒƒãƒ—ã—ãŸã„`token0`ã®é‡ã€‚
- ã‚¹ãƒ¯ãƒƒãƒ—ã—ãŸã„`token1`ã®é‡ã€‚
- ã‚¹ãƒ¯ãƒƒãƒ—ã—ãŸãƒˆãƒ¼ã‚¯ãƒ³ã‚’é€ä¿¡ã™ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- è¿½åŠ ã®ãƒ‡ãƒ¼ã‚¿ã€‚

### 5. æµå‹•æ€§ã®å‰Šé™¤

æµå‹•æ€§ã‚’ãƒ—ãƒ¼ãƒ«ã‹ã‚‰å‰Šé™¤ã—ãŸã„å ´åˆã¯ã€`transfer`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒšã‚¢ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«é€ä¿¡ã—ã¾ã™ã€‚
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç„¼å´ã—ã€å…ƒã®è³‡ç”£ã®ä¸€éƒ¨ã‚’è¿”ã—ã¾ã™ã€‚

### 6. æ®‹é«˜ã¨æ‰¿èªé¡ã®ç¢ºèª

ç‰¹å®šã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã®æ®‹é«˜ã‚’ç¢ºèªã™ã‚‹ã«ã¯ã€`balanceOf`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚
åŒæ§˜ã«ã€ç‰¹å®šã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã®æ‰¿èªé¡ã‚’ç¢ºèªã™ã‚‹ã«ã¯ã€`allowance`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚

ã‚¹ãƒžãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¨ã®å¯¾è©±ã«ã¯ Ethereumãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã¨Solidityãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªžã®ç†è§£ãŒå¿…è¦ã§ã™ã€‚
æœ¬ç•ªç’°å¢ƒã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹å‰ã«å¿…ãšãƒ†ã‚¹ãƒˆãƒãƒƒãƒˆã§ãƒ†ã‚¹ãƒˆã™ã‚‹ã‚ˆã†ã«ã—ã¾ã—ã‚‡ã†ã€‚

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

- `factory`
	- **UniswapV2Pair**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã—ãŸ**UniswapV2Factory**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `token0`
	- **UniswapV2Pair**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆãŒè¡¨ã™ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã®ç‰‡æ–¹ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `token1`
	- **UniswapV2Pair**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆãŒè¡¨ã™ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã®ã‚‚ã†ç‰‡æ–¹ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚


# é–¢æ•°

:::message
ä¸€èˆ¬çš„ãª**ERC20**ãƒˆãƒ¼ã‚¯ãƒ³ã®é–¢æ•°ã«ã¤ã„ã¦ã¯ä»¥ä¸‹ã®è¨˜äº‹ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚
:::

https://chaldene.net/erc20

## READ

### DOMAIN_SEPARATOR

```solidity
function DOMAIN_SEPARATOR() external view returns (bytes32);
```

`permit`é–¢æ•°ã®ç½²åæ¤œè¨¼ã«ä½¿ç”¨ã•ã‚Œã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ã®å€¤ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã€‚
ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ã¯ã€ãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒã‚’é˜²ããŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå›ºæœ‰ã®è­˜åˆ¥å­ã§ã™ã€‚
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®åå‰ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€ãŠã‚ˆã³ãƒã‚§ãƒ¼ãƒ³IDã‚’**keccak256**ãƒãƒƒã‚·ãƒ¥é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦è¨ˆç®—ã•ã‚Œã¾ã™ã€‚
ã“ã®é–¢æ•°ã¯ã€`bytes32`å€¤ã§ã‚ã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã“ã®é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã€æœŸå¾…ã•ã‚Œã‚‹å€¤ã¨è¿”ã•ã‚ŒãŸãƒ‰ãƒ¡ã‚¤ãƒ³ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ã®å€¤ã‚’æ¯”è¼ƒã™ã‚‹ã“ã¨ã§ã€`permit`é–¢æ•°å‘¼ã³å‡ºã—ã®ç½²åã‚’æ¤œè¨¼ã§ãã¾ã™ã€‚
ã“ã®é–¢æ•°ã¯ã€`permit`é–¢æ•°å‘¼ã³å‡ºã—ã®æ•´åˆæ€§ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã«å½¹ç«‹ã¡ã€é–¢æ•°ç½²åã®æ­£å½“æ€§ã‚’æ¤œè¨¼ã™ã‚‹æ‰‹æ®µã‚’æä¾›ã—ã¾ã™ã€‚

### MINIMUM_LIQUIDITY

```solidity
function MINIMUM_LIQUIDITY() external pure returns (uint);
```

`MINIMUM_LIQUIDITY`å®šæ•°ã®å€¤ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã€‚
`MINIMUM_LIQUIDITY`å®šæ•°ã¯ã€æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã«å¯¾ã—ã¦ç”Ÿæˆã•ã‚Œã‚‹æœ€å°ã®æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ã‚’è¡¨ã—ã¾ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæµå‹•æ€§ã‚’æä¾›ã™ã‚‹éš›ã«ã¯ã€`token0`ã¨`token1`ã®ä¸¡æ–¹ã®ç­‰ä¾¡ãªä¾¡å€¤ã‚’ãƒ‡ãƒã‚¸ãƒƒãƒˆã™ã‚‹ã“ã¨ã§ã€æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚
`MINIMUM_LIQUIDITY`ã®å€¤ã¯ã€æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã®åˆæœŸåŒ–æ™‚ã«äº‹å‰ã«è¨­å®šã•ã‚Œã‚‹äºˆã‚å®šç¾©ã•ã‚ŒãŸå€¤ã§ã™ã€‚
`MINIMUM_LIQUIDITY`ã®å€¤ã¯é€šå¸¸ã€ã‚¼ãƒ­ã§ã®å‰²ã‚Šç®—ã‚¨ãƒ©ãƒ¼ã‚’é˜²ãŽã€æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã®æ­£å¸¸ãªå‹•ä½œã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã«å°ã•ãªéžã‚¼ãƒ­ã®å€¤ã¨ãªã‚Šã¾ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã“ã®é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã€æµå‹•æ€§ã‚’ãƒ—ãƒ¼ãƒ«ã«æä¾›ã™ã‚‹éš›ã«ç”Ÿæˆã•ã‚Œã‚‹æœ€å°ã®æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ã‚’å–å¾—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

### PERMIT_TYPEHASH

```solidity
function PERMIT_TYPEHASH() external pure returns (bytes32);
```

`permit`é–¢æ•°ã®ãŸã‚ã®åž‹ãƒãƒƒã‚·ãƒ¥ã‚’æä¾›ã™ã‚‹é–¢æ•°ã€‚
åž‹ãƒãƒƒã‚·ãƒ¥ã¯ã€`permit`é–¢æ•°ã®ç½²åã«å¯¾ã™ã‚‹å›ºæœ‰ã®è­˜åˆ¥å­ã§ã‚ã‚Šã€`EIP712`ç½²åæ¤œè¨¼ãƒ—ãƒ­ã‚»ã‚¹ã§ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
ã“ã®é–¢æ•°ã¯`bytes32`åž‹ã®`PERMIT_TYPEHASH`å¤‰æ•°ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚
ã“ã®é–¢æ•°ã¯ã€`permit`é–¢æ•°è‡ªä½“ã‚„ã€`permit`ç½²åã®æ¤œè¨¼ã‚„å‡¦ç†ã‚’è¡Œã†é–¢æ•°ãªã©ã€`permit`é–¢æ•°ã®åž‹ãƒãƒƒã‚·ãƒ¥ãŒå¿…è¦ãªã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†…ã®ä»–ã®é–¢æ•°ã«ã‚ˆã£ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

### factory

```solidity
function factory() external view returns (address);
```

**Factory**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã€‚
**Factory**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€ã“ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®æ–°ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã§ãã¾ã™ã€‚
ã“ã‚Œã¯ã€ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®æ­£å½“æ€§ã‚’ç¢ºèªã—ãŸã‚Šã€ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¨ç›´æŽ¥å¯¾è©±ã™ã‚‹ãŸã‚ãªã©ã€ã•ã¾ã–ã¾ãªç›®çš„ã§å½¹ç«‹ã¡ã¾ã™ã€‚

:::message
Factoryã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«ã¤ã„ã¦ã¯ä»¥ä¸‹ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚
:::

https://zenn.dev/cryptogames/articles/89744d2e9629f4

### getReserves

```solidity
function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
}
```

ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ç¾åœ¨ã®ãƒªã‚¶ãƒ¼ãƒ–ã¨ãƒªã‚¶ãƒ¼ãƒ–ãŒæœ€å¾Œã«æ›´æ–°ã•ã‚ŒãŸæ™‚ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã€‚
é–¢æ•°ã¯ä»¥ä¸‹ã®3ã¤ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚

- `_reserve0`
	- `token0`ã®ç¾åœ¨ã®ãƒªã‚¶ãƒ¼ãƒ–ã€‚
- `_reserve1`
	- `token1`ã®ç¾åœ¨ã®ãƒªã‚¶ãƒ¼ãƒ–ã€‚
- `_blockTimestampLast`
	- ãƒªã‚¶ãƒ¼ãƒ–ãŒæ›´æ–°ã•ã‚ŒãŸæœ€å¾Œã®ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€‚

### kLast

```solidity
function kLast() external view returns (uint);
```

`kLast`å¤‰æ•°ã®å€¤ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã€‚
`kLast`å¤‰æ•°ã¯ã€æœ€å¾Œã«æµå‹•æ€§ãŒãƒ—ãƒ¼ãƒ«ã«è¿½åŠ ã•ã‚ŒãŸã¨ãã®ã€`token0`ã¨`token1`ã®ãƒªã‚¶ãƒ¼ãƒ–ã®ç©ã®å€¤ã‚’è¡¨ã—ã¾ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã“ã®é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã€`kLast`ã®å€¤ã‚’å–å¾—ã§ãã¾ã™ã€‚

### nonces

```solidity
function nonces(address owner) external view returns (uint);
```

ç‰¹å®šã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«é–¢é€£ã™ã‚‹`nonce`å€¤ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã€‚
`nonce`å€¤ã¯ã€ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰é€ä¿¡ã•ã‚Œã‚‹ã”ã¨ã«å¢—åŠ ã™ã‚‹å›ºæœ‰ã®ç•ªå·ã§ã™ã€‚
ã“ã‚Œã¯ãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒã‚’é˜²ãŽã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®æ•´åˆæ€§ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
é–¢æ•°ã¯ã€æŒ‡å®šã•ã‚ŒãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ã‚­ãƒ¼ã¨ã—ã¦`nonces`ãƒžãƒƒãƒ”ãƒ³ã‚°ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦`nonce`å€¤ã‚’å–å¾—ã—ã¾ã™ã€‚
ã“ã®ãƒžãƒƒãƒ”ãƒ³ã‚°ã¯ã€å„ã‚¢ãƒ‰ãƒ¬ã‚¹ã®`nonce`å€¤ã‚’ä¿æŒã—ã¾ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã“ã®é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã€è‡ªåˆ†è‡ªèº«ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã®`nonce`å€¤ã‚„ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ã‚’æŒã¤ä»–ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã®`nonce`å€¤ã‚’å–å¾—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

### price0CumulativeLast

```solidity
function price0CumulativeLast() external view returns (uint);
```

`price0CumulativeLast`å¤‰æ•°ã®å€¤ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã€‚
`price0CumulativeLast`å¤‰æ•°ã¯ã€`token0`ã¨`token1`ã®é–“ã®ç´¯ç©ä¾¡æ ¼ã‚’ç¤ºã™ã‚‚ã®ã§ã™ã€‚
ç´¯ç©ä¾¡æ ¼ã¨ã¯ã€`token0`ã®ä¾¡æ ¼ã‚’ä¸€å®šã®æœŸé–“å†…ã§åˆè¨ˆã—ãŸã‚‚ã®ã‚’æŒ‡ã—ã¾ã™ã€‚
ã“ã®ç´¯ç©ä¾¡æ ¼ã¯ã€éŽåŽ»ã®æ™‚é–“ã«ã‚ãŸã‚‹ä¾¡æ ¼ã®å¤‰å‹•ã‚’ç¤ºã™é‡è¦ãªæŒ‡æ¨™ã§ã™ã€‚

:::message
ç´¯ç©ä¾¡æ ¼ã¯ã€ç‰¹å®šã®æœŸé–“å†…ã§ã®ä¾¡æ ¼ã®å¤‰å‹•ã‚’åæ˜ ã—ã¾ã™ã€‚
å…·ä½“çš„ã«ã¯ã€ç¾åœ¨ã®æ™‚ç‚¹ã§ã®`token0`ã®ä¾¡æ ¼ã‚’å‰å›žä¾¡æ ¼ãŒæ›´æ–°ã•ã‚Œã¦ã‹ã‚‰ã®æ™‚é–“çµŒéŽã¨ä¹—ç®—ã—ã¦è¨ˆç®—ã•ã‚Œã¾ã™ã€‚
ã“ã®è¨ˆç®—ã«ã‚ˆã‚Šã€éŽåŽ»ã®ä¾¡æ ¼ã®å¤‰å‹•ãŒåˆè¨ˆã•ã‚Œã€ç´¯ç©ä¾¡æ ¼ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚
:::

ã“ã®æƒ…å ±ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®éŽåŽ»ã®ä¾¡æ ¼å¤‰å‹•ã‚’è¿½è·¡ã—ã€æŠ•è³‡åˆ¤æ–­ã‚’è¡Œã†éš›ã«å½¹ç«‹ã¤æƒ…å ±ã¨ãªã‚Šã¾ã™ã€‚

### price1CumulativeLast

```solidity
function price1CumulativeLast() external view returns (uint);
```

`price1CumulativeLast`å¤‰æ•°ã®å€¤ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã€‚
`price1CumulativeLast`å¤‰æ•°ã¯ã€`token0`ã¨`token1`ã®é–“ã®ç´¯ç©ä¾¡æ ¼ã‚’ç¤ºã™ã‚‚ã®ã§ã™ã€‚
ç´¯ç©ä¾¡æ ¼ã¨ã¯ã€`token1`ã®ä¾¡æ ¼ã‚’ä¸€å®šã®æœŸé–“å†…ã§åˆè¨ˆã—ãŸã‚‚ã®ã‚’æŒ‡ã—ã¾ã™ã€‚
ã“ã®ç´¯ç©ä¾¡æ ¼ã¯ã€éŽåŽ»ã®æ™‚é–“ã«ã‚ãŸã‚‹ä¾¡æ ¼ã®å¤‰å‹•ã‚’ç¤ºã™é‡è¦ãªæŒ‡æ¨™ã§ã™ã€‚

### token0

```solidity
function token0() external view returns (address);
```

`token0`å¤‰æ•°ã®å€¤ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€ãƒšã‚¢å†…ã®æœ€åˆã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã§ãã¾ã™ã€‚

### token1

```solidity
function token1() external view returns (address);
```

`token1`å¤‰æ•°ã®å€¤ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€ãƒšã‚¢å†…ã®2ç•ªç›®ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã§ãã¾ã™ã€‚

## WRITE

### initialize

```solidity
function initialize(address _token0, address _token1) external {
        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check
        token0 = _token0;
        token1 = _token1;
}
```

æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã§ä½¿ç”¨ã•ã‚Œã‚‹2ã¤ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’åˆæœŸåŒ–ã™ã‚‹é–¢æ•°ã€‚
`_token0`ã¨`_token1`ã¨ã„ã†2ã¤ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚

é€šå¸¸ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯æ–°ã—ã„ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹éš›ã‚„æ–°ã—ã„æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã™ã‚‹éš›ã«ã€ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚

### permit

```solidity
function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');
        bytes32 digest = keccak256(
            abi.encodePacked(
                '\x19\x01',
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
        _approve(owner, spender, value);
}
```

ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¤‡æ•°ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å¿…è¦ã¨ã›ãšã«ã€åˆ¥ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ã‚ˆã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®æ”¯å‡ºã‚’æ‰¿èªã™ã‚‹ãŸã‚ã®é–¢æ•°ã€‚

æ”¯å‡ºã‚’æ‰¿èªã™ã‚‹å‰ã«ã€é–¢æ•°ã¯ç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã¨`deadline`ã‚’æ¯”è¼ƒã—ã¦`permit`ãŒæœŸé™åˆ‡ã‚Œã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚
ã‚‚ã—`deadline`ã‚’éŽãŽã¦ã„ã‚‹å ´åˆã€é–¢æ•°ã¯**'UniswapV2: EXPIRED'** ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚
ãã®å¾Œã€ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ã€`permit`ã‚¿ã‚¤ãƒ—ãƒãƒƒã‚·ãƒ¥ã€`owner`ã€`spender`ã€`value`ã€`nonce`ã€`deadline`ã‚’å«ã‚€ãƒ‘ãƒƒã‚¯ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆã‚’è¨ˆç®—ã—ã¾ã™ã€‚
ã“ã®ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆã¯ã€ECDSAã®`recover`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦`permit`ã«ç½²åã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å¾©å…ƒã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
å¾©å…ƒã•ã‚ŒãŸã‚¢ãƒ‰ãƒ¬ã‚¹ãŒã‚¼ãƒ­ã§ã¯ãªã„ã“ã¨ã‚’ç¢ºèªã—ã€ã‚ªãƒ¼ãƒŠãƒ¼ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ä¸€è‡´ã™ã‚‹ã“ã¨ã‚’æ¤œè¨¼ã—ã¾ã™ã€‚
ã‚‚ã—æ¤œè¨¼ã«å¤±æ•—ã—ãŸå ´åˆã€é–¢æ•°ã¯**'UniswapV2: INVALID_SIGNATURE'** ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã™ã€‚
æ¤œè¨¼ãŒæˆåŠŸã—ãŸå ´åˆã€é–¢æ•°ã¯å†…éƒ¨ã®`_approve`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€`spender`ã®`allowance`ã‚’æ‰€æœ‰è€…ã®ãƒˆãƒ¼ã‚¯ãƒ³ã«å¯¾ã—ã¦æŒ‡å®šã•ã‚ŒãŸå€¤ã«è¨­å®šã—ã¾ã™ã€‚

**å¼•æ•°**
- `owner`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã®æ‰€æœ‰è€…ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `spender`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã®æ”¯å‡ºã‚’è¨±å¯ã‚’ä¸Žãˆã‚‹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `value`
	- `spender`ãŒä½¿ç”¨ã§ãã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ã€‚
- `deadline`
	- `permit`ã®æœ‰åŠ¹æœŸé™ã¾ã§ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€‚
- `v`ãƒ»`r`ãƒ»`s`
	- ECDSAç½²åã®æ§‹æˆè¦ç´ ã§ã€`permit`ã‚’æ¤œè¨¼ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

### skim

```solidity
function skim(address to) external lock {
        address _token0 = token0; // gas savings
        address _token1 = token1; // gas savings
        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
}
```

ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«è“„ç©ã—ãŸä½™å‰°ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æŒ‡å®šã•ã‚ŒãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã«é€ä¿¡ã™ã‚‹é–¢æ•°ã€‚

`to`ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒã‚¼ãƒ­ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ãªã„ã“ã¨ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚
ã‚‚ã—ã‚¼ãƒ­ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã‚ã‚‹å ´åˆã€é–¢æ•°ã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã¨ã‚‚ã«ãƒªãƒãƒ¼ãƒˆï¼ˆå–ã‚Šæ¶ˆã—ï¼‰ã—ã¾ã™ã€‚

å„ãƒˆãƒ¼ã‚¯ãƒ³ã«å¯¾ã—ã¦`balanceOf`é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®`token0`ãŠã‚ˆã³`token1`ãƒˆãƒ¼ã‚¯ãƒ³ã®ç¾åœ¨ã®æ®‹é«˜ã‚’å–å¾—ã—ã¾ã™ã€‚

:::message
`balanceOf`é–¢æ•°ã¯ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆãŒä¿æŒã—ã¦ã„ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ã‚’è¿”ã—ã¾ã™ã€‚
:::

ã‚‚ã—`token0`ã¾ãŸã¯`token1`ã®æ®‹é«˜ãŒã‚¼ãƒ­ã‚ˆã‚Šå¤§ãã„å ´åˆã€é–¢æ•°ã¯`transfer`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ä½™å‰°ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’`to`ã‚¢ãƒ‰ãƒ¬ã‚¹ã«é€ä¿¡ã—ã¾ã™ã€‚

ã“ã®é–¢æ•°ã¯ã€ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‹ã‚‰ä½™å‰°ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–ã‚Šé™¤ãã€æŒ‡å®šã•ã‚ŒãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã«é€ä¿¡ã™ã‚‹ãŸã‚ã«å½¹ç«‹ã¡ã¾ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«èª¤ã£ã¦é€ä¿¡ã•ã‚ŒãŸå¯èƒ½æ€§ã®ã‚ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–ã‚Šæˆ»ã—ãŸã‚Šã€ç‰¹å®šã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ãƒˆãƒ¼ã‚¯ãƒ³ã‚’é…å¸ƒã—ãŸã‚Šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ã“ã®é–¢æ•°ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæœ‰åŠ¹ãª`to`ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æä¾›ã™ã‚Œã°ã€ã©ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ã‚‚ã„ã¤ã§ã‚‚å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚
ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™ãŸã‚ã®ç‰¹åˆ¥ãªå‰ææ¡ä»¶ã‚„åˆ¶é™ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

**å¼•æ•°**

- `to`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã‚’é€ä»˜ã—ãŸã„ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚


### swap

```solidity
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');

        uint balance0;
        uint balance1;
        { // scope for _token{0,1}, avoids stack too deep errors
        address _token0 = token0;
        address _token1 = token1;
        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));
        }
        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors
        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
        }

        _update(balance0, balance1, _reserve0, _reserve1);
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
}
```

ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒ**UniswapV2**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†…ã§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’äº¤æ›ã™ã‚‹ãŸã‚ã®é–¢æ•°ã€‚

ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã€ã“ã®é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦**UniswapV2**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†…ã§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’äº¤æ›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
å…·ä½“çš„ã«ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³0ã¨ãƒˆãƒ¼ã‚¯ãƒ³1ã®äº¤æ›ã™ã‚‹æ•°é‡ã‚’æŒ‡å®šã—ã€2ã¤ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’äº¤æ›ã—ã¦æŒ‡å®šã•ã‚ŒãŸå—å–äººã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ãƒˆãƒ¼ã‚¯ãƒ³ã‚’é€ã‚Šã¾ã™ã€‚

**å¼•æ•°**

- `amount0Out`
	- ãƒˆãƒ¼ã‚¯ãƒ³0ã‚’äº¤æ›ã™ã‚‹æ•°é‡ã€‚
- `amount1Out`
	- ãƒˆãƒ¼ã‚¯ãƒ³1ã‚’äº¤æ›ã™ã‚‹æ•°é‡ã€‚
- `to`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã®å—å–ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `data`
	- è¿½åŠ ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ãƒã‚¤ãƒˆé…åˆ—ã€‚

### sync

```solidity
function sync() external lock {
        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
}
```

**UniswapV2**ã®ãƒšã‚¢ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†…ã§ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒªã‚¶ãƒ¼ãƒ–ã¨ç´¯ç©ä¾¡æ ¼å€¤ã‚’æœ€æ–°ã®æƒ…å ±ã«æ›´æ–°ã™ã‚‹é–¢æ•°ã€‚

é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã¨ã€ã¾ãš**UniswapV2**ã®ãƒšã‚¢ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆè‡ªä½“ãŒå‘¼ã³å‡ºã—å…ƒã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¾ã™ã€‚
ã‚‚ã—å‘¼ã³å‡ºã—å…ƒãŒãƒšã‚¢ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã§ãªã„å ´åˆã€é–¢æ•°ã¯æ“ä½œã‚’å–ã‚Šæ¶ˆã—ã¦å…ƒã®çŠ¶æ…‹ã«æˆ»ã‚Šã¾ã™ã€‚

ãã®å¾Œã€ãƒšã‚¢ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†…ã§ä¿æŒã•ã‚Œã¦ã„ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³0ã¨ãƒˆãƒ¼ã‚¯ãƒ³1ã®ç¾åœ¨ã®ãƒªã‚¶ãƒ¼ãƒ–ã‚’å–å¾—ã—ã¾ã™ã€‚
æ¬¡ã«ã€é–¢æ•°ã¯**Uniswap Oracle**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‹ã‚‰å¾—ã‚‰ã‚ŒãŸæœ€æ–°ã®ç´¯ç©ä¾¡æ ¼å€¤ã¨ã€ãƒšã‚¢ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†…ã§ä¿å­˜ã•ã‚Œã¦ã„ã‚‹å‰å›žã®ç´¯ç©ä¾¡æ ¼å€¤ã‚’ç”¨ã„ã¦ã€ãƒˆãƒ¼ã‚¯ãƒ³0ã¨ãƒˆãƒ¼ã‚¯ãƒ³1ã®æœ€æ–°ã®ç´¯ç©ä¾¡æ ¼å€¤ã‚’è¨ˆç®—ã—ã¾ã™ã€‚

è¨ˆç®—ã•ã‚ŒãŸæœ€æ–°ã®ç´¯ç©ä¾¡æ ¼å€¤ã§ã€ãƒšã‚¢ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†…ã§ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ç´¯ç©ä¾¡æ ¼å€¤ã‚’æ›´æ–°ã—ã¾ã™ã€‚

ã“ã‚Œã«ã‚ˆã‚Šã€æ­£ç¢ºãªä¾¡æ ¼è¨ˆç®—ã¨**Uniswap**ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¸Šã§ã®å–å¼•ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

# ã‚¤ãƒ™ãƒ³ãƒˆ

## Swap

åˆ†æ•£åž‹å–å¼•æ‰€ã§2ã¤ã®ãƒˆãƒ¼ã‚¯ãƒ³é–“ã§ã‚¹ãƒ¯ãƒƒãƒ—ãŒè¡Œã‚ã‚Œã‚‹ãŸã³ã«ãƒˆãƒªã‚¬ãƒ¼ã•ã‚Œã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã€‚
ã“ã®ã‚¤ãƒ™ãƒ³ãƒˆã«ã¯6ã¤ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™ã€‚

- `sender`
	- ã‚¹ãƒ¯ãƒƒãƒ—ã‚’é–‹å§‹ã™ã‚‹é€ä¿¡è€…ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `amount0In`
	- ã‚¹ãƒ¯ãƒƒãƒ—ã«å…¥åŠ›ã•ã‚Œã‚‹ãƒˆãƒ¼ã‚¯ãƒ³0ã®æ•°é‡ã€‚
- `amount1In`
	- ã‚¹ãƒ¯ãƒƒãƒ—ã«å…¥åŠ›ã•ã‚Œã‚‹ãƒˆãƒ¼ã‚¯ãƒ³1ã®æ•°é‡ã€‚
- `amount0Out`
	- ã‚¹ãƒ¯ãƒƒãƒ—ã‹ã‚‰å‡ºåŠ›ã•ã‚Œã‚‹ãƒˆãƒ¼ã‚¯ãƒ³0ã®æ•°é‡ã€‚
- `amount1Out`
	- ã‚¹ãƒ¯ãƒƒãƒ—ã‹ã‚‰å‡ºåŠ›ã•ã‚Œã‚‹ãƒˆãƒ¼ã‚¯ãƒ³1ã®æ•°é‡ã€‚
- `to`
	- å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å—ã‘å–ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚

ã“ã®ã‚¤ãƒ™ãƒ³ãƒˆã¯`sender`ã¨`to`ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒä»˜ã‘ã‚‰ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã«ã‚ˆã£ã¦ã“ã‚Œã‚‰ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¦ç‰¹å®šã®ã‚¹ãƒ¯ãƒƒãƒ—ã‚’ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°ã‹ã‚‰ã‚¯ã‚¨ãƒªã™ã‚‹éš›ã«ãƒ•ã‚£ãƒ«ã‚¿ã¨ã—ã¦ä½¿ç”¨ã§ãã¾ã™ã€‚
è¦ç´„ã™ã‚‹ã¨ã€`Swap`ã‚¤ãƒ™ãƒ³ãƒˆã¯åˆ†æ•£åž‹å–å¼•æ‰€ã§ç™ºç”Ÿã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¹ãƒ¯ãƒƒãƒ—ã«é–¢ã™ã‚‹é‡è¦ãªæƒ…å ±ã‚’æä¾›ã—ã€é€ä¿¡è€…ã€å…¥åŠ›ãŠã‚ˆã³å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã€å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã®å—å–äººãªã©ãŒå«ã¾ã‚Œã¾ã™ã€‚

## Sync

**Uniswap**ã®ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã®æº–å‚™ãŒèª¿æ•´ã•ã‚Œã‚‹åº¦ã«ç™ºç”Ÿã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæµå‹•æ€§ã‚„å–å¼•æ´»å‹•ã®å¤‰åŒ–ã‚’è¿½è·¡ã§ãã‚‹ã‚ˆã†ã«æƒ…å ±ã‚’æä¾›ã—ã¾ã™ã€‚
ã“ã®ã‚¤ãƒ™ãƒ³ãƒˆã«ã¯2ã¤ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™ã€‚

- `reserve0`
	- æœ€åˆã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒªã‚¶ãƒ¼ãƒ–ã®æ›´æ–°ã•ã‚ŒãŸå€¤ã€‚
- `reserve1`
	- 2ç•ªç›®ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒªã‚¶ãƒ¼ãƒ–ã®æ›´æ–°ã•ã‚ŒãŸå€¤ã€‚


# ã‚³ãƒ¼ãƒ‰

## IUniswapV2Pair

:::details IUniswapV2Pair

```solidity
// File: contracts/interfaces/IUniswapV2Pair.sol

pragma solidity >=0.5.0;

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}
```
:::

## IUniswapV2ERC20

:::details IUniswapV2ERC20

```solidity
// File: contracts/interfaces/IUniswapV2ERC20.sol

pragma solidity >=0.5.0;

interface IUniswapV2ERC20 {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
}
```
:::

## SafeMath

:::details SafeMath
```solidity
// File: contracts/libraries/SafeMath.sol

pragma solidity =0.5.16;

// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)

library SafeMath {
    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x, 'ds-math-add-overflow');
    }

    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x - y) <= x, 'ds-math-sub-underflow');
    }

    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');
    }
}
```
:::

## UniswapV2ERC20

:::details UniswapV2ERC20
```solidity
// File: contracts/UniswapV2ERC20.sol

pragma solidity =0.5.16;



contract UniswapV2ERC20 is IUniswapV2ERC20 {
    using SafeMath for uint;

    string public constant name = 'Uniswap V2';
    string public constant symbol = 'UNI-V2';
    uint8 public constant decimals = 18;
    uint  public totalSupply;
    mapping(address => uint) public balanceOf;
    mapping(address => mapping(address => uint)) public allowance;

    bytes32 public DOMAIN_SEPARATOR;
    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    mapping(address => uint) public nonces;

    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    constructor() public {
        uint chainId;
        assembly {
            chainId := chainid
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
                keccak256(bytes(name)),
                keccak256(bytes('1')),
                chainId,
                address(this)
            )
        );
    }

    function _mint(address to, uint value) internal {
        totalSupply = totalSupply.add(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(address(0), to, value);
    }

    function _burn(address from, uint value) internal {
        balanceOf[from] = balanceOf[from].sub(value);
        totalSupply = totalSupply.sub(value);
        emit Transfer(from, address(0), value);
    }

    function _approve(address owner, address spender, uint value) private {
        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _transfer(address from, address to, uint value) private {
        balanceOf[from] = balanceOf[from].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(from, to, value);
    }

    function approve(address spender, uint value) external returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transfer(address to, uint value) external returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function transferFrom(address from, address to, uint value) external returns (bool) {
        if (allowance[from][msg.sender] != uint(-1)) {
            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
        }
        _transfer(from, to, value);
        return true;
    }

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');
        bytes32 digest = keccak256(
            abi.encodePacked(
                '\x19\x01',
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
        _approve(owner, spender, value);
    }
}
```
:::

## Mathãƒ»UQ112x112

:::details Mathãƒ»UQ112x112
```solidity
// File: contracts/libraries/Math.sol

pragma solidity =0.5.16;

// a library for performing various math operations

library Math {
    function min(uint x, uint y) internal pure returns (uint z) {
        z = x < y ? x : y;
    }

    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint y) internal pure returns (uint z) {
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}

// File: contracts/libraries/UQ112x112.sol

pragma solidity =0.5.16;

// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))

// range: [0, 2**112 - 1]
// resolution: 1 / 2**112

library UQ112x112 {
    uint224 constant Q112 = 2**112;

    // encode a uint112 as a UQ112x112
    function encode(uint112 y) internal pure returns (uint224 z) {
        z = uint224(y) * Q112; // never overflows
    }

    // divide a UQ112x112 by a uint112, returning a UQ112x112
    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
        z = x / uint224(y);
    }
}
```
:::

## IERC20

:::details IERC20
```solidity
// File: contracts/interfaces/IERC20.sol

pragma solidity >=0.5.0;

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
}
```
:::

## IUniswapV2Factory

:::details IUniswapV2Factory
```solidity
// File: contracts/interfaces/IUniswapV2Factory.sol

pragma solidity >=0.5.0;

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}
```
:::

## IUniswapV2Callee

:::details IUniswapV2Callee
```solidity
// File: contracts/interfaces/IUniswapV2Callee.sol

pragma solidity >=0.5.0;

interface IUniswapV2Callee {
    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;
}
```
:::

## UniswapV2Pair

:::details UniswapV2Pair
```solidity
// File: contracts/interfaces/IUniswapV2Pair.sol

pragma solidity >=0.5.0;

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}

// File: contracts/interfaces/IUniswapV2ERC20.sol

pragma solidity >=0.5.0;

interface IUniswapV2ERC20 {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
}

// File: contracts/libraries/SafeMath.sol

pragma solidity =0.5.16;

// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)

library SafeMath {
    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x, 'ds-math-add-overflow');
    }

    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x - y) <= x, 'ds-math-sub-underflow');
    }

    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');
    }
}

// File: contracts/UniswapV2ERC20.sol

pragma solidity =0.5.16;



contract UniswapV2ERC20 is IUniswapV2ERC20 {
    using SafeMath for uint;

    string public constant name = 'Uniswap V2';
    string public constant symbol = 'UNI-V2';
    uint8 public constant decimals = 18;
    uint  public totalSupply;
    mapping(address => uint) public balanceOf;
    mapping(address => mapping(address => uint)) public allowance;

    bytes32 public DOMAIN_SEPARATOR;
    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    mapping(address => uint) public nonces;

    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    constructor() public {
        uint chainId;
        assembly {
            chainId := chainid
        }
        DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
                keccak256(bytes(name)),
                keccak256(bytes('1')),
                chainId,
                address(this)
            )
        );
    }

    function _mint(address to, uint value) internal {
        totalSupply = totalSupply.add(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(address(0), to, value);
    }

    function _burn(address from, uint value) internal {
        balanceOf[from] = balanceOf[from].sub(value);
        totalSupply = totalSupply.sub(value);
        emit Transfer(from, address(0), value);
    }

    function _approve(address owner, address spender, uint value) private {
        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _transfer(address from, address to, uint value) private {
        balanceOf[from] = balanceOf[from].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(from, to, value);
    }

    function approve(address spender, uint value) external returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transfer(address to, uint value) external returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function transferFrom(address from, address to, uint value) external returns (bool) {
        if (allowance[from][msg.sender] != uint(-1)) {
            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
        }
        _transfer(from, to, value);
        return true;
    }

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');
        bytes32 digest = keccak256(
            abi.encodePacked(
                '\x19\x01',
                DOMAIN_SEPARATOR,
                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');
        _approve(owner, spender, value);
    }
}

// File: contracts/libraries/Math.sol

pragma solidity =0.5.16;

// a library for performing various math operations

library Math {
    function min(uint x, uint y) internal pure returns (uint z) {
        z = x < y ? x : y;
    }

    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint y) internal pure returns (uint z) {
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}

// File: contracts/libraries/UQ112x112.sol

pragma solidity =0.5.16;

// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))

// range: [0, 2**112 - 1]
// resolution: 1 / 2**112

library UQ112x112 {
    uint224 constant Q112 = 2**112;

    // encode a uint112 as a UQ112x112
    function encode(uint112 y) internal pure returns (uint224 z) {
        z = uint224(y) * Q112; // never overflows
    }

    // divide a UQ112x112 by a uint112, returning a UQ112x112
    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
        z = x / uint224(y);
    }
}

// File: contracts/interfaces/IERC20.sol

pragma solidity >=0.5.0;

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
}

// File: contracts/interfaces/IUniswapV2Factory.sol

pragma solidity >=0.5.0;

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

// File: contracts/interfaces/IUniswapV2Callee.sol

pragma solidity >=0.5.0;

interface IUniswapV2Callee {
    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;
}

// File: contracts/UniswapV2Pair.sol

pragma solidity =0.5.16;

contract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 {
    using SafeMath  for uint;
    using UQ112x112 for uint224;

    uint public constant MINIMUM_LIQUIDITY = 10**3;
    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));

    address public factory;
    address public token0;
    address public token1;

    uint112 private reserve0;           // uses single storage slot, accessible via getReserves
    uint112 private reserve1;           // uses single storage slot, accessible via getReserves
    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves

    uint public price0CumulativeLast;
    uint public price1CumulativeLast;
    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event

    uint private unlocked = 1;
    modifier lock() {
        require(unlocked == 1, 'UniswapV2: LOCKED');
        unlocked = 0;
        _;
        unlocked = 1;
    }

    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }

    function _safeTransfer(address token, address to, uint value) private {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');
    }

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    constructor() public {
        factory = msg.sender;
    }

    // called once by the factory at time of deployment
    function initialize(address _token0, address _token1) external {
        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check
        token0 = _token0;
        token1 = _token1;
    }

    // update reserves and, on the first call per block, price accumulators
    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'UniswapV2: OVERFLOW');
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
            // * never overflows, and + overflow is desired
            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
        }
        reserve0 = uint112(balance0);
        reserve1 = uint112(balance1);
        blockTimestampLast = blockTimestamp;
        emit Sync(reserve0, reserve1);
    }

    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
        address feeTo = IUniswapV2Factory(factory).feeTo();
        feeOn = feeTo != address(0);
        uint _kLast = kLast; // gas savings
        if (feeOn) {
            if (_kLast != 0) {
                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));
                uint rootKLast = Math.sqrt(_kLast);
                if (rootK > rootKLast) {
                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));
                    uint denominator = rootK.mul(5).add(rootKLast);
                    uint liquidity = numerator / denominator;
                    if (liquidity > 0) _mint(feeTo, liquidity);
                }
            }
        } else if (_kLast != 0) {
            kLast = 0;
        }
    }

    // this low-level function should be called from a contract which performs important safety checks
    function mint(address to) external lock returns (uint liquidity) {
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        uint balance0 = IERC20(token0).balanceOf(address(this));
        uint balance1 = IERC20(token1).balanceOf(address(this));
        uint amount0 = balance0.sub(_reserve0);
        uint amount1 = balance1.sub(_reserve1);

        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        if (_totalSupply == 0) {
            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
        } else {
            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
        }
        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');
        _mint(to, liquidity);

        _update(balance0, balance1, _reserve0, _reserve1);
        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
        emit Mint(msg.sender, amount0, amount1);
    }

    // this low-level function should be called from a contract which performs important safety checks
    function burn(address to) external lock returns (uint amount0, uint amount1) {
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        address _token0 = token0;                                // gas savings
        address _token1 = token1;                                // gas savings
        uint balance0 = IERC20(_token0).balanceOf(address(this));
        uint balance1 = IERC20(_token1).balanceOf(address(this));
        uint liquidity = balanceOf[address(this)];

        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
        require(amount0 > 0 && amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');
        _burn(address(this), liquidity);
        _safeTransfer(_token0, to, amount0);
        _safeTransfer(_token1, to, amount1);
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));

        _update(balance0, balance1, _reserve0, _reserve1);
        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
        emit Burn(msg.sender, amount0, amount1, to);
    }

    // this low-level function should be called from a contract which performs important safety checks
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');

        uint balance0;
        uint balance1;
        { // scope for _token{0,1}, avoids stack too deep errors
        address _token0 = token0;
        address _token1 = token1;
        require(to != _token0 && to != _token1, 'UniswapV2: INVALID_TO');
        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));
        }
        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors
        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
        }

        _update(balance0, balance1, _reserve0, _reserve1);
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
    }

    // force balances to match reserves
    function skim(address to) external lock {
        address _token0 = token0; // gas savings
        address _token1 = token1; // gas savings
        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
    }

    // force reserves to match balances
    function sync() external lock {
        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
    }
}
```
:::

# æœ€å¾Œã«

ä»Šå›žã®è¨˜äº‹ã§ã¯ã€Bunzzã®æ–°æ©Ÿèƒ½ã€Ž**DeCipher**ã€ã‚’ä½¿ç”¨ã—ã¦ã€**UniswapV2**ã®ã€Œ**UniswapV2Pair**ã€ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’è¦‹ã¦ãã¾ã—ãŸã€‚
ã„ã‹ãŒã ã£ãŸã§ã—ã‚‡ã†ã‹ï¼Ÿ
ä»Šå¾Œã‚‚ç‰¹å®šã®NFTã‚„ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ãƒ”ãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã¦ã¾ã¨ã‚ã¦è¡ŒããŸã„ã¨æ€ã„ã¾ã™ã€‚

æ™®æ®µã¯ãƒ–ãƒ­ã‚°ã‚„Qiitaã§ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚„AIã«é–¢ã™ã‚‹è¨˜äº‹ã‚’æŒ™ã’ã¦ã„ã‚‹ã®ã§ã€ã‚ˆã‘ã‚Œã°è¦‹ã¦ã„ã£ã¦ãã ã•ã„ï¼

https://chaldene.net/

https://qiita.com/cardene
