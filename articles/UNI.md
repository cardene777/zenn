---
title: "[Bunzz Decipher] Uniswapã®UNIãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ç†è§£ã—ã‚ˆã†ï¼"
emoji: "ğŸ¦„"
type: "tech"
topics:
  - "blockchain"
  - "ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³"
  - "solidity"
  - "ethereum"
  - "defi"
published: true
published_at: "2023-08-14 07:04"
publication_name: "cryptogames"
---

# ã¯ã˜ã‚ã«

åˆã‚ã¾ã—ã¦ã€‚
**CryptoGames**ã¨ã„ã†ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚²ãƒ¼ãƒ ä¼æ¥­ã§ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã‚’ã—ã¦ã„ã‚‹ **cardeneï¼ˆã‹ã‚‹ã§ã­ï¼‰** ã§ã™ï¼
ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’æ›¸ã„ãŸã‚Šã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ»ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ»ã‚¤ãƒ³ãƒ•ãƒ©ã¨å¹…åºƒãè§¦ã‚Œã¦ã„ã¾ã™ã€‚

https://cryptogames.co.jp/

ä»£è¡¨çš„ãªã‚²ãƒ¼ãƒ ã¯**ã‚¯ãƒªãƒ—ãƒˆã‚¹ãƒšãƒ«ã‚º**ã¨ã„ã†ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚²ãƒ¼ãƒ ã§ã™ã€‚

https://cryptospells.jp/

ä»Šå›ã¯Bunzzã®æ–°æ©Ÿèƒ½ã€**DeCipher**ã€ã‚’ä½¿ç”¨ã—ã¦ã€Uniswapã®ã€Œ**Uni**ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’è¦‹ã¦ã¿ã‚ˆã†ã¨æ€ã„ã¾ã™ã€‚

ã€**DeCipher**ã€ã¯AIã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’è‡ªå‹•ç”Ÿæˆã—ã¦ãã‚Œã‚‹ã‚µãƒ¼ãƒ“ã‚¹ã§ã™ã€‚

https://www.bunzz.dev/decipher

è©³ã—ã„ä½¿ã„æ–¹ã«é–¢ã—ã¦ã¯ä»¥ä¸‹ã®è¨˜äº‹ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ï¼

https://zenn.dev/heku/articles/33266f0c19d523

:::message
ã“ã®è¨˜äº‹ã¯ã‚ãã¾ã§å€‹äººãŒã€ŒDeCipherã€ã‚’ä½¿ç”¨ã—ã¦ã¿ã¦ã®è¨˜äº‹ã«ãªã‚Šã¾ã™ã€‚
é–“é•ã£ãŸéƒ¨åˆ†ãªã©ã‚‚ã‚ã‚‹ã‹ã¨æ€ã„ã¾ã™ãŒã€ãã®éš›ã¯ã‚³ãƒ¡ãƒ³ãƒˆãªã©ã§æ•™ãˆã¦ãã ã•ã„ã€‚
:::

ä»Šå›ä½¿ç”¨ã™ã‚‹ã€**DeCipher**ã€ã®ãƒªãƒ³ã‚¯ã¯ä»¥ä¸‹ã«ãªã‚Šã¾ã™ã€‚

https://app.bunzz.dev/decipher/chains/1/addresses/0x1f9840a85d5af5bf1d1762f925bdaddc4201f984

# æ¦‚è¦

**Uni**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯Ethereumãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ä¸Šã«å±•é–‹ã•ã‚ŒãŸã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã§ã™ã€‚
ã“ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯**Uniswap**ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆ**UNI**ï¼‰ã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚
**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã¯**ERC20**ãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚ã‚Šã€ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œã€é…å¸ƒã€ç®¡ç†ã‚’æ‹…å½“ã—ã¦ã„ã¾ã™ã€‚

## ç›®çš„
**Uni**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ä¸»ãªç›®çš„ã¯**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç®¡ç†ã™ã‚‹ã“ã¨ã§ã™ã€‚
ã“ã‚Œã«ã¯ã€æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆé–“ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®è»¢é€ã€ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å¯¾ã—ã¦ãƒˆãƒ¼ã‚¯ãƒ³ã®ä½¿ç”¨ã‚’è¨±å¯ã™ã‚‹æ©Ÿèƒ½ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚

ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«ã¯ç‰¹å®šã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æ®‹é«˜ã‚’ç¢ºèªã™ã‚‹æ©Ÿèƒ½ã€Mintã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å¤‰æ›´ã™ã‚‹æ©Ÿèƒ½ã€è»¢é€ã€æ‰¿èªã€Mintã‚¢ãƒ‰ãƒ¬ã‚¹ã®å¤‰æ›´ãªã©ã®é‡è¦ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«é–¢ã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œã™ã‚‹æ©Ÿèƒ½ã‚‚å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚

## ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®è²¬ä»»ç¯„å›²

### ãƒˆãƒ¼ã‚¯ãƒ³ã®ç®¡ç†
**Uni**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã®ç·ä¾›çµ¦ã‚’ç®¡ç†ã™ã‚‹è²¬ä»»ãŒã‚ã‚Šã¾ã™ã€‚
ç·ä¾›çµ¦ã¯åˆã‚ã«10å„„**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã«è¨­å®šã•ã‚Œã¾ã™ã€‚
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã¾ãŸã€**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã®åå‰ã€ã‚·ãƒ³ãƒœãƒ«ã€å°æ•°ç‚¹ä»¥ä¸‹æ¡æ•°ã‚’æŒ‡å®šã—ã¾ã™ã€‚
ãã‚Œãã‚Œã®å€¤ã¯ã€Œ**Uniswap**ã€ã€ã€Œ**UNI**ã€ã€ãŠã‚ˆã³`18`ã§ã™ã€‚

### æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œ
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«ã¯`minter`ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå«ã¾ã‚Œã¦ãŠã‚Šã€æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã®Mintã‚’è¡Œã†å”¯ä¸€ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã¾ãŸã€å„`minter`ã”ã¨ã«ç™ºè¡Œã§ãã‚‹ç·ä¾›çµ¦ã®æœ€å¤§å‰²åˆã‚’ç¤ºã™Mintã‚­ãƒ£ãƒƒãƒ—ã‚’æŒ‡å®šã—ã¾ã™ã€‚
Minté–“éš”ã®æœ€å°æ™‚é–“ã¯365æ—¥ã§ã™ã€‚

### ãƒˆãƒ¼ã‚¯ãƒ³ã®è»¢é€
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€é€ä¿¡è€…ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‹ã‚‰å®›å…ˆã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¸ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è»¢é€ã™ã‚‹ãŸã‚ã®æ©Ÿèƒ½ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚
è»¢é€ã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°ã¯é–¢æ•°ã§æŒ‡å®šã•ã‚Œã¾ã™ã€‚

### ä»–è€…ã¸ã®ãƒˆãƒ¼ã‚¯ãƒ³ä½¿ç”¨ã®æ‰¿èª
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®æ‰€æœ‰è€…ãŒä»–ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«ä¸€å®šé‡ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ä½¿ç”¨ã‚’è¨±å¯ã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚
ã“ã‚Œã¯æ‰¿èªé–¢æ•°ã‚’ä»‹ã—ã¦è¡Œã‚ã‚Œã€å¼•æ•°ã¨ã—ã¦å¯¾è±¡ã¨ãªã‚‹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ãŒæŒ‡å®šã•ã‚Œã¾ã™ã€‚

### ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæ®‹é«˜ã®ç¢ºèª
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ç‰¹å®šã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æ®‹é«˜ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã®æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚
ã“ã®é–¢æ•°ã¯ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒä¿æŒã—ã¦ã„ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã‚’è¿”ã—ã¾ã™ã€‚

### Mintã‚¢ãƒ‰ãƒ¬ã‚¹ã®å¤‰æ›´
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã§ã¯`minter`ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å¤‰æ›´ã‚‚å¯èƒ½ã§ã™ã€‚
ã“ã‚Œã¯æ–°ã—ã„M`minter`ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å¼•æ•°ã¨ã—ã¦å—ã‘å–ã‚‹`changeMinter`é–¢æ•°ã‚’ä»‹ã—ã¦è¡Œã‚ã‚Œã¾ã™ã€‚

### ã‚¤ãƒ™ãƒ³ãƒˆã®ç™ºè¡Œ
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯è»¢é€ã€æ‰¿èªã€ãƒŸãƒ³ã‚¿ãƒ¼ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å¤‰æ›´ãªã©ã®é‡è¦ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«é–¢ã™ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œã—ã¾ã™ã€‚
ã“ã‚Œã‚‰ã®ã‚¤ãƒ™ãƒ³ãƒˆã¯å¤–éƒ¨ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ãŒã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®æ´»å‹•ã‚’è¿½è·¡ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã¾ã™ã€‚

ã¾ã¨ã‚ã‚‹ã¨ã€**Uni**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç®¡ç†ã™ã‚‹åŒ…æ‹¬çš„ãªã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã§ã™ã€‚
ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œã€é…å¸ƒã€ç®¡ç†ã«å¿…è¦ãªã™ã¹ã¦ã®æ©Ÿèƒ½ã‚’æä¾›ã—ã€**Uniswap**ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ã®é‡è¦ãªè¦ç´ ã¨ãªã£ã¦ã„ã¾ã™ã€‚

# ä½¿ã„æ–¹

**Uni**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€Ethereumãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ä¸Šã®**Uniswap**ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆ**UNI**ï¼‰ã«é–¢ã™ã‚‹ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã§ã™ã€‚
ã“ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯**EIP20**ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¨™æº–ã«å¾“ã„ã¤ã¤ã€æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œãªã©ã®è¿½åŠ æ©Ÿèƒ½ã‚’æŒã£ã¦ã„ã¾ã™ã€‚
ä»¥ä¸‹ã¯ã€ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚„é–‹ç™ºè€…ã®è¦–ç‚¹ã‹ã‚‰**Uni**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ä½¿ç”¨ã™ã‚‹æ‰‹é †æ¡ˆå†…ã§ã™ã€‚

## ç›®æ¨™
**Uni**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ç›®æ¨™ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®è»¢é€ã€æ‰¿èªã€æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œã€Mintã‚¢ãƒ‰ãƒ¬ã‚¹ã®å¤‰æ›´ãªã©ã€**Uniswap**ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆ**UNI**ï¼‰ã®æ“ä½œã‚’ç®¡ç†ã™ã‚‹ã“ã¨ã§ã™ã€‚

### ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ãƒ‡ãƒ—ãƒ­ã‚¤

ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯Ethereumãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ä¸Šã«å±•é–‹ã•ã‚Œã¾ã™ã€‚
åˆæœŸã®ãƒŸãƒ³ã‚¿ãƒ¼ãŠã‚ˆã³ç™ºè¡ŒãŒå¯èƒ½ã«ãªã‚‹ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã¯å±•é–‹æ™‚ã«è¨­å®šã•ã‚Œã¾ã™ã€‚

### ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¨ã®ã‚„ã‚Šå–ã‚Š

ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆãŒå±•é–‹ã•ã‚Œã‚‹ã¨ã€ãã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã‚„ã‚Šå–ã‚ŠãŒå¯èƒ½ã§ã™ã€‚
ä»¥ä¸‹ã«ä¸»ãªé–¢æ•°ã¨ãã®ä½¿ã„æ–¹ã‚’ç¤ºã—ã¾ã™ã€‚

#### 2.1. ãƒˆãƒ¼ã‚¯ãƒ³ã®è»¢é€

`transfer`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡è€…ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‹ã‚‰åˆ¥ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è»¢é€ã—ã¾ã™ã€‚

#### 2.2. ãƒˆãƒ¼ã‚¯ãƒ³ã®ä½¿ç”¨æ‰¿èª

`approve`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€åˆ¥ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«å¯¾ã—ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡è€…ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‹ã‚‰ä¸€å®šé‡ã®**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã®ä½¿ç”¨ã‚’è¨±å¯ã—ã¾ã™ã€‚

#### 2.3. ãƒŸãƒ³ã‚¿ãƒ¼ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å¤‰æ›´

`setMinter`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€Mintã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å¤‰æ›´ã—ã¾ã™ã€‚
ã“ã®é–¢æ•°ã¯ç¾åœ¨ã®Minterã®ã¿ãŒå‘¼ã³å‡ºã›ã¾ã™ã€‚

#### 2.4. æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œ

`mint`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦æ–°ã—ã„**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½œæˆã—ã¾ã™ã€‚
ã“ã®é–¢æ•°ã¯Minterã®ã¿ãŒå‘¼ã³å‡ºã›ã€ç‰¹å®šã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®å¾Œã«ã®ã¿å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚

## ä½¿ç”¨ã‚·ãƒŠãƒªã‚ª

### ãƒˆãƒ¼ã‚¯ãƒ³ã®è»¢é€ã¨æ‰¿èª

**Uni**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ã‚¢ã‚«ã‚¦ãƒ³ãƒˆé–“ã§è»¢é€ã—ãŸã‚Šã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡è€…ã®ä»£ã‚ã‚Šã«ä»–ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã®ä½¿ç”¨ã‚’æ‰¿èªã—ãŸã‚Šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã¾ã™ã€‚

### æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œ

**Uni**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ä½¿ç”¨ã—ã¦æ–°ã—ã„**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ã“ã‚Œã¯`mint`é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§è¡Œã‚ã‚Œã€Minterã®ã¿ãŒç‰¹å®šã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®å¾Œã«å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚

### Mintã‚¢ãƒ‰ãƒ¬ã‚¹ã®å¤‰æ›´

**Uni**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯Mintã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ã“ã‚Œã¯`setMinter`é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§è¡Œã‚ã‚Œã€ç¾åœ¨ã®Minterã®ã¿ãŒå‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚
æœ¬ç•ªãƒãƒƒãƒˆã«å±•é–‹ã™ã‚‹å‰ã«ã€å¸¸ã«ãƒ†ã‚¹ãƒˆãƒãƒƒãƒˆä¸Šã§ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¨ã®ã‚„ã‚Šå–ã‚Šã‚’ãƒ†ã‚¹ãƒˆã—ã¦ã€å–ã‚Šè¿”ã—ã®ã¤ã‹ãªã„ãƒŸã‚¹ã‚’é¿ã‘ã‚‹ã‚ˆã†ã«ã—ã¾ã—ã‚‡ã†ã€‚

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

## account

**Uni**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚

## minter_
**Uni**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã‚‹`minter`ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚

## mintingAllowedAfter

**Uni**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã§MintãŒé–‹å§‹ã•ã‚Œã‚‹æ™‚é–“ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆ`Unix`ã‚¨ãƒãƒƒã‚¯å½¢å¼ï¼‰ã€‚

# å¤‰æ•°ãƒ»å®šæ•°ãƒ»é…åˆ—

## å¤‰æ•°

### totalSupply

```solidity
uint public totalSupply = 1_000_000_000e18; // 1 billion Uni
```

**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã®ç·ç™ºè¡Œé‡ã€‚
10å„„æšãŒç™ºè¡Œä¸Šé™ã¨ãªã£ã¦ã„ã‚‹ã€‚

### minter

```solidity
address public minter;
```

ãƒˆãƒ¼ã‚¯ãƒ³ã‚’Mintã§ãã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚

### mintingAllowedAfter

```solidity
uint public mintingAllowedAfter;
```

ãƒˆãƒ¼ã‚¯ãƒ³ã‚’Mintã§ãã‚‹ã‚ˆã†ã«ãªã‚‹æ™‚é–“ã‚’ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã§è¡¨ã—ã¦ã„ã‚‹ã€‚

## å®šæ•°

### minimumTimeBetweenMints

```solidity
uint32 public constant minimumTimeBetweenMints = 1 days * 365;
```

å‰å›ã®Mintã‹ã‚‰æœ€ä½ã©ã®ãã‚‰ã„ã®æ™‚é–“çµŒéã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã®å€¤ã€‚
**UNI**ãƒˆãƒ¼ã‚¯ãƒ³ã§ã¯ã€1å¹´ã¨å®šç¾©ã—ã¦ã„ã‚‹ã€‚

### mintCap

```solidity
uint8 public constant mintCap = 2;
```

1åº¦ã®Mintã§`totalSupply`ã®ä½•%ç™ºè¡Œã§ãã‚‹ã‹ã®å€¤ã€‚
`2`ã¨å®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€`totalSupply`ã®2%ä»¥ä¸‹ã¨åˆ¶é™ã•ã‚Œã¦ã„ã‚‹ã€‚

### DOMAIN_TYPEHASH

```solidity
bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");
```

**EIP712**ãƒ‰ãƒ¡ã‚¤ãƒ³ã®ã‚¿ã‚¤ãƒ—ãƒãƒƒã‚·ãƒ¥ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚
**EIP712**ã¯ã€ã‚¤ãƒ¼ã‚µãƒªã‚¢ãƒ ä¸Šã§æ¨™æº–çš„ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç½²åæ–¹æ³•ã‚’æä¾›ã™ã‚‹ãŸã‚ã®è¦æ ¼ã§ã‚ã‚Šã€ãƒ‰ãƒ¡ã‚¤ãƒ³åˆ†é›¢ï¼ˆDomain Separationï¼‰ã¨ã„ã†ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®æ¦‚å¿µã‚’å°å…¥ã—ã¦ã„ã¾ã™ã€‚

:::message
ãƒ‰ãƒ¡ã‚¤ãƒ³åˆ†é›¢ï¼ˆ**Domain Separation**ï¼‰ã¯ã€æƒ…å ±ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®æ¦‚å¿µã®ä¸€ã¤ã§ã€ç•°ãªã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚„ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆé–“ã§ã®ãƒ‡ãƒ¼ã‚¿ã‚„å‡¦ç†ã‚’åˆ†é›¢ã™ã‚‹ã“ã¨ã‚’æŒ‡ã—ã¾ã™ã€‚
ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã€ç•°ãªã‚‹ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ«ã‚„ä¿¡é ¼æ€§ã®è¦ä»¶ã‚’æŒã¤ã‚·ã‚¹ãƒ†ãƒ ã‚„ãƒ—ãƒ­ã‚»ã‚¹ã‚’ä¿è­·ã—ã€ãƒ‡ãƒ¼ã‚¿æ¼æ´©ã‚„æ”»æ’ƒã‚’é˜²ããŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚„æš—å·é€šè²¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã¯ã€ãƒ‰ãƒ¡ã‚¤ãƒ³åˆ†é›¢ã¯ç‰¹ã«é‡è¦ã§ã™ã€‚
ä¾‹ãˆã°ã€**EIP712**ã®ã‚ˆã†ãªç½²åãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚
ãƒ‰ãƒ¡ã‚¤ãƒ³åˆ†é›¢ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«ã¯ã€ç•°ãªã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã®å‡¦ç†ã‚„ãƒ‡ãƒ¼ã‚¿ã®æ··åŒã‚’é¿ã‘ã‚‹ãŸã‚ã«ã€ç‰¹å®šã®è­˜åˆ¥å­ï¼ˆãƒã‚§ãƒ¼ãƒ³IDã‚„ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ãªã©ï¼‰ã‚’ç”¨ã„ã¦ãƒ‡ãƒ¼ã‚¿ã‚„å‡¦ç†ã‚’åŒºåˆ¥ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

å…·ä½“çš„ã«ã¯ã€ãƒ‰ãƒ¡ã‚¤ãƒ³åˆ†é›¢ã‚’å°å…¥ã™ã‚‹ã“ã¨ã§ã€ç•°ãªã‚‹ãƒã‚§ãƒ¼ãƒ³ã‚„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–“ã§ã®ãƒ‡ãƒ¼ã‚¿ã®æµç”¨ã‚„ã€æ”»æ’ƒè€…ãŒãƒ‡ãƒ¼ã‚¿ã‚„ç½²åã‚’å†åˆ©ç”¨ã—ã¦ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’ä¹±ã™ã“ã¨ã‚’é˜²ãã“ã¨ãŒã§ãã¾ã™ã€‚**EIP712**ã®ã‚ˆã†ãªç½²åæ©Ÿèƒ½ã«ãŠã„ã¦ã€ãƒ‰ãƒ¡ã‚¤ãƒ³åˆ†é›¢ã¯ç½²åã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’é«˜ã‚ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã”ã¨ã«ç•°ãªã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒãƒƒã‚·ãƒ¥ã‚’åˆ©ç”¨ã™ã‚‹ã“ã¨ã§ã€ãƒ‡ãƒ¼ã‚¿ã®æ··åŒã‚„æ”»æ’ƒã‚’é˜²ãå½¹å‰²ã‚’æœãŸã—ã¾ã™ã€‚
:::

- `name`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã®åå‰ã‚’è¡¨ã™æ–‡å­—åˆ—ã€‚
- `chainId`
	- ãƒã‚§ãƒ¼ãƒ³ã®è­˜åˆ¥å­ã‚’è¡¨ã™æ•´æ•°å€¤ï¼ˆã‚¤ãƒ¼ã‚µãƒªã‚¢ãƒ ãƒ¡ã‚¤ãƒ³ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãªã©ã®ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã”ã¨ã«ç•°ãªã‚‹å€¤ï¼‰ã€‚
- `verifyingContract`
	- ç½²åã‚’æ¤œè¨¼ã™ã‚‹ãŸã‚ã®ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚

### DELEGATION_TYPEHASH

```solidity
bytes32 public constant DELEGATION_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");
```

**EIP712**ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ä¸€éƒ¨ã¨ã—ã¦ã€ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†…ã§ã®ãƒ‡ãƒªã‚²ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæŠ•ç¥¨æ¨©å§”ä»»ï¼‰ã«é–¢ã™ã‚‹æƒ…å ±ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã€‚

- `delegatee`
	- å§”ä»»å…ˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `nonce`
	- å§”ä»»ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªç•ªå·ã€‚
- `expiry`
	- å§”ä»»ã®æœ‰åŠ¹æœŸé™ã€‚

### PERMIT_TYPEHASH

```solidity
bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
```

**EIP712**ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ä¸€éƒ¨ã¨ã—ã¦ã€ãƒˆãƒ¼ã‚¯ãƒ³æ‰€æœ‰è€…ãŒç‰¹å®šã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«å¯¾ã—ã¦ãƒˆãƒ¼ã‚¯ãƒ³ã®ä½¿ç”¨è¨±å¯ã‚’ä¸ãˆã‚‹ãŸã‚ã®æƒ…å ±ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã€‚

- `owner`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã®æ‰€æœ‰è€…ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `spender`
	- è¨±å¯ã•ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `value`
	- è¨±å¯ã•ã‚Œã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ã€‚
- `nonce`
	- ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªç•ªå·ã€‚
- `deadline`
	- ç½²åã®æœ‰åŠ¹æœŸé™ã€‚

## é…åˆ—

### delegates

```solidity
mapping (address => address) public delegates;
```

ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã”ã¨ã«ãƒ‡ãƒªã‚²ãƒ¼ãƒˆï¼ˆä»£ç†ï¼‰ã‚’ä¿æŒã™ã‚‹ãŸã‚ã®ãƒãƒƒãƒ”ãƒ³ã‚°é…åˆ—ã€‚

å„ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ã‚­ãƒ¼ã¨ã—ã€ãã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒãƒ‡ãƒªã‚²ãƒ¼ãƒˆã—ã¦ã„ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å€¤ã¨ã—ã¦é–¢é€£ä»˜ã‘ã¦ã„ã¾ã™ã€‚
ã¤ã¾ã‚Šã€å„ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¯åˆ¥ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«å¯¾ã—ã¦æ“ä½œæ¨©é™ã‚’å§”ä»»ï¼ˆãƒ‡ãƒªã‚²ãƒ¼ãƒˆï¼‰ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

:::message
ã“ã“ã§è¨€ã†ã€Œ**ãƒ‡ãƒªã‚²ãƒ¼ãƒˆ**ã€ã¨ã¯ã€ä¸€ã¤ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒåˆ¥ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«å¯¾ã—ã¦ã€ç‰¹å®šã®æ“ä½œï¼ˆä¾‹ãˆã°ãƒˆãƒ¼ã‚¯ãƒ³ã®ç§»å‹•ã‚„æŠ•ç¥¨ãªã©ï¼‰ã‚’è¡Œã†æ¨©é™ã‚’ä¸ãˆã‚‹ã“ã¨ã‚’æŒ‡ã—ã¾ã™ã€‚
ãƒ‡ãƒªã‚²ãƒ¼ãƒˆé–¢ä¿‚ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®æ‰€æœ‰æ¨©ã‚„ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†…ã§ã®æ“ä½œæ¨©é™ã‚’åŠ¹æœçš„ã«ç®¡ç†ã™ã‚‹ãŸã‚ã®ä»•çµ„ã¿ã§ã™ã€‚
ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæ‰€æœ‰è€…ãŒä¸€æ™‚çš„ã«åˆ¥ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«æ“ä½œæ¨©é™ã‚’å§”ä»»ã™ã‚‹ã“ã¨ã§ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚„åŠ¹ç‡æ€§ã‚’å‘ä¸Šã•ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
:::


### checkpoints

```solidity
struct Checkpoint {
uint32 fromBlock;
uint96 votes;
}

mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;
```

ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã”ã¨ã«è¤‡æ•°ã®æŠ•ç¥¨æ•°ã®å±¥æ­´ã‚’ä¿æŒã™ã‚‹ãŸã‚ã®ãƒãƒƒãƒ”ãƒ³ã‚°é…åˆ—ã€‚

`Checkpoint`æ§‹é€ ä½“ã§ã¯ã€ç‰¹å®šã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«å¯¾ã—ã¦ãƒ–ãƒ­ãƒƒã‚¯ã”ã¨ã®æŠ•ç¥¨æ•°ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ã€‚

- `fromBlock`
	- æŠ•ç¥¨æ•°ãŒã©ã®ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰å§‹ã¾ã£ãŸã‹ã‚’ç¤ºã™ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ï¼ˆuint32å‹ï¼‰ã€‚
- `votes`
	- ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰ã®æŠ•ç¥¨æ•°ã‚’ç¤ºã™æ•°å€¤ï¼ˆuint96å‹ï¼‰ã€‚

å¤–å´ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã®ã‚­ãƒ¼ã¯ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã€å†…å´ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã®ã‚­ãƒ¼ã¯ç‰¹å®šã®ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ï¼ˆuint32å‹ï¼‰ã§ã™ã€‚
ãƒãƒƒãƒ”ãƒ³ã‚°ã®å€¤ã¯ã€`Checkpoint`æ§‹é€ ä½“ã‚’æ ¼ç´ã—ã¦ãŠã‚Šã€å„ãƒ–ãƒ­ãƒƒã‚¯ã”ã¨ã®æŠ•ç¥¨æ•°ã®å±¥æ­´ãŒãã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«å¯¾ã—ã¦è¨˜éŒ²ã•ã‚Œã¦ã„ã¾ã™ã€‚
ç‰¹å®šã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒã‚ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã‹ã‚‰åˆ¥ã®ãƒ–ãƒ­ãƒƒã‚¯ã«ã‹ã‘ã¦è¡Œã£ãŸæŠ•ç¥¨ã®å±¥æ­´ã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
å„ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æŠ•ç¥¨å±¥æ­´ãŒãƒ–ãƒ­ãƒƒã‚¯ã”ã¨ã«è¨˜éŒ²ã•ã‚Œã€å¿…è¦ãªå ´åˆã«éå»ã®æŠ•ç¥¨æ•°ã‚’ç¢ºèªã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

### numCheckpoints

```solidity
mapping (address => uint32) public numCheckpoints;
```

å„ã‚¢ãƒ‰ãƒ¬ã‚¹ã”ã¨ã«ãã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«é–¢é€£ã™ã‚‹æŠ•ç¥¨æ•°ã®å±¥æ­´ï¼ˆãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆï¼‰ã®æ•°ã‚’ä¿æŒã™ã‚‹ãŸã‚ã®ãƒãƒƒãƒ”ãƒ³ã‚°é…åˆ—ã€‚

å„ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒä¿æŒã™ã‚‹æŠ•ç¥¨æ•°ã®å±¥æ­´ã®æ•°ã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
ç‰¹å®šã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æŠ•ç¥¨æ•°ã®å¤‰æ›´ãŒè¡Œã‚ã‚Œã‚‹ãŸã³ã«ã€æ–°ã—ã„ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãŒä½œæˆã•ã‚Œã€ãã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®`numCheckpoints`ãƒãƒƒãƒ”ãƒ³ã‚°ã®å€¤ãŒæ›´æ–°ã•ã‚Œã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€ç‰¹å®šã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æŠ•ç¥¨æ•°ã®å±¥æ­´æ•°ã‚’åŠ¹ç‡çš„ã«è¿½è·¡ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

### nonces

```solidity
mapping (address => uint) public nonces;
```

å„ã‚¢ãƒ‰ãƒ¬ã‚¹ã«å¯¾ã—ã¦ç½²åã«é–¢é€£ã™ã‚‹çŠ¶æ…‹æƒ…å ±ã‚’ä¿æŒã™ã‚‹ãŸã‚ã®ãƒãƒƒãƒ”ãƒ³ã‚°é…åˆ—ã€‚
ç‰¹å®šã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒç½²åã‚’è¡Œã†éš›ã«ã€ä¸€æ„ã®çŠ¶æ…‹æƒ…å ±ï¼ˆ`nonce`ï¼‰ã‚’ç”Ÿæˆã—ã€ãã®å¾Œã®ç½²åæ“ä½œã«ãŠã„ã¦é‡è¤‡ã‚’é¿ã‘ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
å…·ä½“çš„ã«ã¯ã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒç½²åã‚’ç”Ÿæˆã™ã‚‹ãŸã³ã«ã€é–¢é€£ã™ã‚‹`nonces`ãƒãƒƒãƒ”ãƒ³ã‚°ã®å€¤ãŒã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã•ã‚Œã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã”ã¨ã«ä¸€æ„ã®çŠ¶æ…‹æƒ…å ±ãŒæä¾›ã•ã‚Œã€ç½²åã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨æ•´åˆæ€§ãŒç¢ºä¿ã•ã‚Œã¾ã™ã€‚

:::message
ç½²åæ“ä½œã«ãŠã„ã¦ã€ä¸€åº¦ä½¿ç”¨ã•ã‚ŒãŸçŠ¶æ…‹æƒ…å ±ã¯æ¬¡å›ä»¥é™ã®ç½²åæ“ä½œã§ã¯ä½¿ç”¨ã•ã‚Œãªã„ãŸã‚ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’å‘ä¸Šã•ã›ã‚‹ã®ã«å½¹ç«‹ã¡ã¾ã™ã€‚
:::


# é–¢æ•°

## constructor

```solidity
require(mintingAllowedAfter_ >= block.timestamp, "Uni::constructor: minting can only begin after deployment");
```
æŒ‡å®šã•ã‚ŒãŸmintingAllowedAfter_ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãŒãƒ‡ãƒ—ãƒ­ã‚¤ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»¥é™ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚

ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡ŒãŒãƒ‡ãƒ—ãƒ­ã‚¤å¾Œã«ã®ã¿è¨±å¯ã•ã‚Œã‚‹ã‚ˆã†ã«åˆ¶é™ã—ã¦ã„ã¾ã™ã€‚
ã‚‚ã—`mintingAllowedAfter_`ãŒãƒ‡ãƒ—ãƒ­ã‚¤æ™‚åˆ»ã‚ˆã‚Šå‰ã§ã‚ã‚Œã°ã€ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã¦ãƒ‡ãƒ—ãƒ­ã‚¤ãŒä¸­æ­¢ã•ã‚Œã¾ã™ã€‚

```solidity
balances[account] = uint96(totalSupply);
```
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆå†…ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æ®‹é«˜ã‚’åˆæœŸåŒ–ã—ã¦ã„ã¾ã™ã€‚

æŒ‡å®šã•ã‚ŒãŸã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æ®‹é«˜ã‚’ãƒˆãƒ¼ã‚¿ãƒ«ä¾›çµ¦é‡ï¼ˆ`totalSupply`ï¼‰ã«è¨­å®šã—ã¦ã„ã¾ã™ã€‚

```solidity
emit Transfer(address(0), account, totalSupply);
```
ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒãƒˆãƒ¼ã‚¯ãƒ³ã®ç§»å‹•ï¼ˆè»¢é€ï¼‰ã‚’ç¤ºã™Transferã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œã—ã¦ã„ã¾ã™ã€‚

ãƒˆãƒ¼ã‚¯ãƒ³ãŒã‚¢ãƒ‰ãƒ¬ã‚¹`0`ã‹ã‚‰æŒ‡å®šã•ã‚ŒãŸã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«é€ä¿¡ã•ã‚ŒãŸã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚

```solidity
minter = minter_;
```
ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œè€…ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨­å®šã—ã¦ã„ã¾ã™ã€‚

```solidity
emit MinterChanged(address(0), minter);
```
`minter`ãŒå¤‰æ›´ã•ã‚ŒãŸã“ã¨ã‚’ç¤ºã™`MinterChanged`ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œã—ã¦ã„ã¾ã™ã€‚
`minter`ãŒã‚¢ãƒ‰ãƒ¬ã‚¹`0`ã‹ã‚‰æŒ‡å®šã•ã‚ŒãŸ`minter`ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«å¤‰æ›´ã•ã‚ŒãŸã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚

```solidity
mintingAllowedAfter = mintingAllowedAfter_;
```

ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡ŒãŒè¨±å¯ã•ã‚Œã‚‹ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’è¨­å®šã—ã¦ã„ã¾ã™ã€‚

## READ

### getCurrentVotes

```solidity
function getCurrentVotes(address account) external view returns (uint96) {
        uint32 nCheckpoints = numCheckpoints[account];
        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
}
```

æŒ‡å®šã•ã‚ŒãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã®ç¾åœ¨ã®æŠ•ç¥¨ãƒãƒ©ãƒ³ã‚¹ã‚’å–å¾—ã™ã‚‹ãŸã‚ã®é–¢æ•°ã€‚

`nCheckpoints`ã¯ã€æŒ‡å®šã•ã‚ŒãŸã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«é–¢é€£ã™ã‚‹ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®æ•°ã‚’æ ¼ç´ã—ã¾ã™ã€‚
ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æŠ•ç¥¨å±¥æ­´ã®æ•°ã‚’ç¢ºèªã§ãã¾ã™ã€‚
æŠ•ç¥¨å±¥æ­´ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ã€æœ€æ–°ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‹ã‚‰å¾—ã‚‰ã‚Œã‚‹æŠ•ç¥¨æ•° (`votes`) ã‚’è¿”ã—ã¾ã™ã€‚
å­˜åœ¨ã—ãªã„å ´åˆã¯ã€`0`ã‚’è¿”ã—ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€æŒ‡å®šã•ã‚ŒãŸã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ç¾åœ¨ã®æŠ•ç¥¨ãƒãƒ©ãƒ³ã‚¹ã‚’å–å¾—ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

### getPriorVotes

```solidity
function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {
        require(blockNumber < block.number, "Uni::getPriorVotes: not yet determined");

        uint32 nCheckpoints = numCheckpoints[account];
        if (nCheckpoints == 0) {
            return 0;
        }

        // First check most recent balance
        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nCheckpoints - 1].votes;
        }

        // Next check implicit zero balance
        if (checkpoints[account][0].fromBlock > blockNumber) {
            return 0;
        }

        uint32 lower = 0;
        uint32 upper = nCheckpoints - 1;
        while (upper > lower) {
            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
            Checkpoint memory cp = checkpoints[account][center];
            if (cp.fromBlock == blockNumber) {
                return cp.votes;
            } else if (cp.fromBlock < blockNumber) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }
        return checkpoints[account][lower].votes;
}
```

ç‰¹å®šã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ç‰¹å®šã®ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·(`blockNumber`)æ™‚ç‚¹ã§ã®äº‹å‰ã®æŠ•ç¥¨æ•°ã‚’æ±ºå®šã™ã‚‹ãŸã‚ã®é–¢æ•°ã€‚

1. æŒ‡å®šã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ãŒç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ã‚ˆã‚Šã‚‚éå»ã®ã‚‚ã®ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚
æœªæ¥ã®ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ã«å¯¾ã—ã¦æŠ•ç¥¨æ•°ã‚’è¨ˆç®—ã™ã‚‹ã“ã¨ã‚’é˜²ããŸã‚ã§ã™ã€‚
2. `nCheckpoints`ã¯ã€æŒ‡å®šã•ã‚ŒãŸã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«é–¢é€£ã™ã‚‹ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®æ•°ã‚’æ ¼ç´ã—ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æŠ•ç¥¨å±¥æ­´ã®æ•°ã‚’ç¢ºèªã§ãã¾ã™ã€‚
3. ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æŠ•ç¥¨å±¥æ­´ãŒå­˜åœ¨ã—ãªã„å ´åˆã€äº‹å‰ã®æŠ•ç¥¨æ•°ã‚’`0`ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚
4. æœ€æ–°ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãŒæŒ‡å®šã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ã‚ˆã‚Šã‚‚éå»ã§ã‚ã‚‹å ´åˆã€ãã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®æŠ•ç¥¨æ•°ã‚’è¿”ã—ã¾ã™ã€‚
æŒ‡å®šã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ä»¥å‰ã®æœ€æ–°ã®æŠ•ç¥¨æ•°ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚
5. æœ€ã‚‚å¤ã„ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãŒæŒ‡å®šã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ã‚ˆã‚Šã‚‚æœªæ¥ã®å ´åˆã€äº‹å‰ã®æŠ•ç¥¨æ•°ã‚’`0`ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚
æŒ‡å®šã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ã‚ˆã‚Šã‚‚å¤ã„æŠ•ç¥¨å±¥æ­´ãŒå­˜åœ¨ã—ãªã„ã“ã¨ã‚’ç¢ºèªã§ãã¾ã™ã€‚
6. `lower`ã¨`upper`ã¯ã€äºŒåˆ†æ¢ç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã«ä½¿ç”¨ã•ã‚Œã‚‹å¤‰æ•°ã§ã™ã€‚
åˆæœŸå€¤ã¨ã—ã¦ã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æŠ•ç¥¨å±¥æ­´å†…ã§ã®æ¢ç´¢ç¯„å›²ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã™ã€‚
7. ãƒ«ãƒ¼ãƒ—ã§äºŒåˆ†æ¢ç´¢ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ç”¨ã—ã¦æŒ‡å®šã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ã«æœ€ã‚‚è¿‘ã„ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’è¦‹ã¤ã‘ã¾ã™ã€‚
8. `center`ã§ç¤ºã•ã‚Œã‚‹ä½ç½®ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’ä¸€æ™‚çš„ãªå¤‰æ•°`cp`ã«æ ¼ç´ã—ã¾ã™ã€‚
9. ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ãŒæŒ‡å®šã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ã¨ä¸€è‡´ã™ã‚‹å ´åˆã€ãã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®æŠ•ç¥¨æ•°ã‚’è¿”ã—ã¾ã™ã€‚
10. æ¢ç´¢ç¯„å›²ã‚’æ›´æ–°ã—ã¦æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ã«é€²ã‚€ãŸã‚ã®æ¡ä»¶åˆ†å²ã‚’è¡Œã„ã¾ã™ã€‚
ã‚‚ã—ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ãŒæŒ‡å®šã•ã‚ŒãŸãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ã‚ˆã‚Šã‚‚å°ã•ã„å ´åˆã¯ã€æ¢ç´¢ç¯„å›²ã®ä¸‹é™ã‚’`center`ã«è¨­å®šã—ã¾ã™ã€‚
é€†ã«ã€å¤§ãã„å ´åˆã¯æ¢ç´¢ç¯„å›²ã®ä¸Šé™ã‚’æ›´æ–°ã—ã¾ã™ã€‚
11. æœ€çµ‚çš„ã«ã€æœ€ã‚‚è¿‘ã„ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’è¦‹ã¤ã‘ãŸå¾Œã€ãã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®æŠ•ç¥¨æ•°ã‚’è¿”ã—ã¾ã™ã€‚

### safe32

```solidity
function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {
        require(n < 2**32, errorMessage);
        return uint32(n);
}
```

ä¸ãˆã‚‰ã‚ŒãŸæ•´æ•°`n`ãŒ`32`ãƒ“ãƒƒãƒˆæœªæº€ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã€æ¡ä»¶ã«åˆè‡´ã™ã‚‹å ´åˆã¯`n`ã‚’`uint32`å‹ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚
ã‚‚ã—`n`ãŒ`32`ãƒ“ãƒƒãƒˆã‚’è¶…ãˆã‚‹å ´åˆã€ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã¨ã‚‚ã«ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚

### safe96

```solidity
function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {
        require(n < 2**96, errorMessage);
        return uint96(n);
}
```

ä¸ãˆã‚‰ã‚ŒãŸæ•´æ•°`n`ãŒ`96`ãƒ“ãƒƒãƒˆæœªæº€ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã€æ¡ä»¶ã«åˆè‡´ã™ã‚‹å ´åˆã¯`n`ã‚’`uint96`å‹ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚
ã‚‚ã—`n`ãŒ`96`ãƒ“ãƒƒãƒˆã‚’è¶…ãˆã‚‹å ´åˆã€ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã¨ã‚‚ã«ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚

### add96
```solidity
function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {
        uint96 c = a + b;
        require(c >= a, errorMessage);
        return c;
}
```

ä¸ãˆã‚‰ã‚ŒãŸ2ã¤ã®`96`ãƒ“ãƒƒãƒˆæ•´æ•°`a`ã¨`b`ã‚’åŠ ç®—ã—ã€çµæœã‚’`uint96`å‹ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚
åŠ ç®—æ™‚ã«ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã€æ¡ä»¶ã«åˆè‡´ã—ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã¨ã‚‚ã«ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚


### sub96
```solidity
function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {
        require(b <= a, errorMessage);
        return a - b;
}
```

ä¸ãˆã‚‰ã‚ŒãŸ2ã¤ã®`96`ãƒ“ãƒƒãƒˆæ•´æ•°`a`ã‹ã‚‰`b`ã‚’æ¸›ç®—ã—ã€çµæœã‚’`uint96`å‹ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚
æ¸›ç®—æ™‚ã«ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ•ãƒ­ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã€æ¡ä»¶ã«åˆè‡´ã—ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¨ã¨ã‚‚ã«ã‚¨ãƒ©ãƒ¼ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚

### getChainId

```solidity
function getChainId() internal pure returns (uint) {
        uint256 chainId;
        assembly { chainId := chainid() }
        return chainId;
}
```

Ethereumãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ãƒã‚§ãƒ¼ãƒ³IDã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
`assembly`ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½¿ç”¨ã—ã¦`chainid()`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã€å–å¾—ã—ãŸãƒã‚§ãƒ¼ãƒ³IDã‚’`uint`å‹ã§è¿”ã—ã¾ã™ã€‚

## WRITE

### setMinter

```solidity
function setMinter(address minter_) external {
        require(msg.sender == minter, "Uni::setMinter: only the minter can change the minter address");
        emit MinterChanged(minter, minter_);
        minter = minter_;
}
```
æ–°ã—ã„`minter`ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨­å®šã™ã‚‹é–¢æ•°ã€‚
ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç™ºè¡Œã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ãŒç¾åœ¨ã®`minter`ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ä¸€è‡´ã™ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚
å¤‰æ›´æ“ä½œã¯ã€ç¾åœ¨ã®`minter`ï¼ˆãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œè€…ï¼‰ã«ã‚ˆã£ã¦ã®ã¿å®Ÿè¡Œã§ãã¾ã™ã€‚
ã‚‚ã—æ¡ä»¶ã‚’æº€ãŸã•ãªã„å ´åˆã€ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã¦é–¢æ•°ã®å®Ÿè¡ŒãŒä¸­æ­¢ã•ã‚Œã¾ã™ã€‚

### mint

```solidity
function mint(address dst, uint rawAmount) external {
        require(msg.sender == minter, "Uni::mint: only the minter can mint");
        require(block.timestamp >= mintingAllowedAfter, "Uni::mint: minting not allowed yet");
        require(dst != address(0), "Uni::mint: cannot transfer to the zero address");

        // record the mint
        mintingAllowedAfter = SafeMath.add(block.timestamp, minimumTimeBetweenMints);

        // mint the amount
        uint96 amount = safe96(rawAmount, "Uni::mint: amount exceeds 96 bits");
        require(amount <= SafeMath.div(SafeMath.mul(totalSupply, mintCap), 100), "Uni::mint: exceeded mint cap");
        totalSupply = safe96(SafeMath.add(totalSupply, amount), "Uni::mint: totalSupply exceeds 96 bits");

        // transfer the amount to the recipient
        balances[dst] = add96(balances[dst], amount, "Uni::mint: transfer amount overflows");
        emit Transfer(address(0), dst, amount);

        // move delegates
        _moveDelegates(address(0), delegates[dst], amount);
}
```

æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç™ºè¡Œã™ã‚‹é–¢æ•°ã€‚

1. ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç™ºè¡Œã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ãŒç¾åœ¨ã®`minter`ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ä¸€è‡´ã™ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚
ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œã¯ã€`minter`ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ã‚ˆã£ã¦ã®ã¿è¨±å¯ã•ã‚Œã¦ã„ã¾ã™ã€‚

2. ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡ŒãŒè¨±å¯ã•ã‚ŒãŸã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»¥é™ã®æ™‚ç‚¹ã§ã‚ã‚‹ã‹ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚
æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»¥å‰ã«ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç™ºè¡Œã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

3. ãƒˆãƒ¼ã‚¯ãƒ³ã‚’é€ä¿¡ã™ã‚‹å®›å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ãŒã‚¼ãƒ­ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ãªã„ã“ã¨ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚
ã‚¼ãƒ­ã‚¢ãƒ‰ãƒ¬ã‚¹ã¸ã®é€ä¿¡ã¯ç„¡åŠ¹ã§ã™ã€‚

4. ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œå¾Œã€æ¬¡ã«ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç™ºè¡Œã§ãã‚‹ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’æ›´æ–°ã—ã¦ã„ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œé–“éš”ãŒåˆ¶å¾¡ã•ã‚Œã¾ã™ã€‚

5. ç™ºè¡Œã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ã‚’è¨ˆç®—ã—ã¦`amount`ã¨ã„ã†å¤‰æ•°ã«æ ¼ç´ã—ã¦ã„ã¾ã™ã€‚

6. ç™ºè¡Œã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ãŒç¾åœ¨ã®ç·ä¾›çµ¦é‡ã®ä¸€å®šå‰²åˆã‚’è¶…ãˆãªã„ã“ã¨ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚
ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œé‡ã«åˆ¶é™ã‚’è¨­ã‘ã‚‹ã“ã¨ã§ã€é€šè²¨ã®ã‚¤ãƒ³ãƒ•ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã—ã¦ã„ã¾ã™ã€‚

7. ç·ä¾›çµ¦é‡ã‚’æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œã«åˆã‚ã›ã¦æ›´æ–°ã—ã¦ã„ã¾ã™ã€‚

8. å®›å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã®æ®‹é«˜ã‚’å¢—ã‚„ã—ã¦ã€æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œã‚’åæ˜ ã•ã›ã¦ã„ã¾ã™ã€‚

9. ãƒˆãƒ¼ã‚¯ãƒ³ã®é€ä¿¡ãŒè¡Œã‚ã‚ŒãŸã“ã¨ã‚’ç¤ºã™`Transfer`ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œã—ã¦ã„ã¾ã™ã€‚

10. ãƒˆãƒ¼ã‚¯ãƒ³ã®ç™ºè¡Œã«ä¼´ã„ã€ãƒ‡ãƒªã‚²ãƒ¼ãƒˆï¼ˆæŠ•ç¥¨æ¨©ã®å§”ä»»å…ˆï¼‰ã‚’ç§»å‹•ã™ã‚‹ãŸã‚ã®å†…éƒ¨é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã„ã¾ã™ã€‚

### permit

```solidity
function permit(address owner, address spender, uint rawAmount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
        uint96 amount;
        if (rawAmount == uint(-1)) {
            amount = uint96(-1);
        } else {
            amount = safe96(rawAmount, "Uni::permit: amount exceeds 96 bits");
        }

        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));
        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, rawAmount, nonces[owner]++, deadline));
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
        address signatory = ecrecover(digest, v, r, s);
        require(signatory != address(0), "Uni::permit: invalid signature");
        require(signatory == owner, "Uni::permit: unauthorized");
        require(now <= deadline, "Uni::permit: signature expired");

        allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);
}
```

ç‰¹å®šã®ãƒˆãƒ¼ã‚¯ãƒ³æ‰€æœ‰è€…ãŒåˆ¥ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«å¯¾ã—ã¦æ”¯å‡ºã‚’æ‰¿èªã™ã‚‹ãŸã‚ã®é–¢æ•°ã€‚

1. æ‰¿èªã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ã‚’è¨ˆç®—ã—ã¦ã„ã¾ã™ã€‚
`rawAmount`ãŒ`-1`ã§ã‚ã‚Œã°ã€ç„¡é™ã«æ‰¿èªã•ã‚ŒãŸã“ã¨ã‚’ç¤ºã™ãŸã‚ã«`amount`ã‚’`-1`ã«è¨­å®šã—ã¾ã™ã€‚
ãã‚Œä»¥å¤–ã®å ´åˆã€96ãƒ“ãƒƒãƒˆã®ç¯„å›²å†…ã«åã‚ã‚‹ãŸã‚ã«`safe96`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦`rawAmount`ã‚’å¤‰æ›ã—ã¾ã™ã€‚

2. ãƒ‰ãƒ¡ã‚¤ãƒ³åˆ†é›¢ã®ãŸã‚ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’è¨ˆç®—ã—ã¦ã„ã¾ã™ã€‚
ã“ã®ãƒãƒƒã‚·ãƒ¥ã¯ã€**EIP712**ãƒ‰ãƒ¡ã‚¤ãƒ³ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’çµ„ã¿åˆã‚ã›ãŸã‚‚ã®ã§ã™ã€‚

3. æ‰¿èªæ§‹é€ ä½“ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’è¨ˆç®—ã—ã¦ã„ã¾ã™ã€‚
ã“ã®ãƒãƒƒã‚·ãƒ¥ã¯ã€æ‰¿èªã®å„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’çµ„ã¿åˆã‚ã›ãŸã‚‚ã®ã§ã™ã€‚
æ‰€æœ‰è€…ã®ãƒãƒ³ã‚¹ï¼ˆã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ï¼‰ã‚‚ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦ã„ã¾ã™ã€‚

4. ç½²åã®å¯¾è±¡ã¨ãªã‚‹ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆã‚’è¨ˆç®—ã—ã¦ã„ã¾ã™ã€‚
**EIP191**ç½²åã®ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ï¼ˆ`\x19\x01`ï¼‰ã‚’å«ã‚€ã€ãƒ‰ãƒ¡ã‚¤ãƒ³åˆ†é›¢ã¨æ‰¿èªæ§‹é€ ä½“ã®ãƒãƒƒã‚·ãƒ¥å€¤ã‚’çµ„ã¿åˆã‚ã›ãŸã‚‚ã®ã§ã™ã€‚

5. ç½²åã‹ã‚‰ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å›å¾©ã—ã¾ã™ã€‚
èª°ãŒãƒˆãƒ¼ã‚¯ãƒ³ã®æ‰¿èªã‚’è¡Œã£ã¦ã„ã‚‹ã‹ã‚’ç¢ºèªã§ãã¾ã™ã€‚

6. å›å¾©ã•ã‚ŒãŸã‚¢ãƒ‰ãƒ¬ã‚¹ãŒã‚¼ãƒ­ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ãªã„ã“ã¨ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚

7. æ‰¿èªã‚’è¡Œã£ã¦ã„ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒãƒˆãƒ¼ã‚¯ãƒ³æ‰€æœ‰è€…ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ä¸€è‡´ã™ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚

8. æ‰¿èªã®ç½²åãŒæœ‰åŠ¹æœŸé™å†…ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚

9. æ‰¿èªãƒªã‚¹ãƒˆï¼ˆãƒˆãƒ¼ã‚¯ãƒ³æ‰€æœ‰è€…ãŒç‰¹å®šã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«å¯¾ã—ã¦ã©ã‚Œã ã‘ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ‰¿èªã—ã¦ã„ã‚‹ã‹ï¼‰ã‚’æ›´æ–°ã—ã¦ã„ã¾ã™ã€‚

10. æ‰¿èªãŒè¡Œã‚ã‚ŒãŸã“ã¨ã‚’ç¤ºã™Approvalã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œã—ã¦ã„ã¾ã™ã€‚

### delegate

```solidity
function delegate(address delegatee) public {
        return _delegate(msg.sender, delegatee);
}
```

ãƒˆãƒ¼ã‚¯ãƒ³æ‰€æœ‰è€…ãŒæŠ•ç¥¨æ¨©ã‚’ä»–ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«å§”ä»»ã™ã‚‹ãŸã‚ã®é–¢æ•°ã€‚
`_delegate`é–¢æ•°ã«å‡¦ç†ã‚’å§”è­²ã—ã¦ã„ã¾ã™ã€‚

### delegateBySig

```solidity
function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {
        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));
        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
        address signatory = ecrecover(digest, v, r, s);
        require(signatory != address(0), "Uni::delegateBySig: invalid signature");
        require(nonce == nonces[signatory]++, "Uni::delegateBySig: invalid nonce");
        require(now <= expiry, "Uni::delegateBySig: signature expired");
        return _delegate(signatory, delegatee);
}
```

ç½²åã‚’ä½¿ç”¨ã—ã¦ãƒˆãƒ¼ã‚¯ãƒ³æ‰€æœ‰è€…ãŒæŠ•ç¥¨æ¨©ã‚’ä»–ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«å§”ä»»ã™ã‚‹ãŸã‚ã®é–¢æ•°ã€‚
ç½²åã«é–¢é€£ã™ã‚‹æƒ…å ±ï¼ˆ`nonce`ã€`expiry`ã€`v`ã€`r`ã€`s`ï¼‰ãŒå¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚Œã¾ã™ã€‚

1. `domainSeparator`ã¯ã€ç½²åã®æ¤œè¨¼ã«ä½¿ç”¨ã•ã‚Œã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ãƒ‰ãƒ¡ã‚¤ãƒ³æƒ…å ±ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦ç”Ÿæˆã•ã‚Œã¾ã™ã€‚
2. `structHash`ã¯ã€å§”ä»»æ§‹é€ ä½“ã®ãƒãƒƒã‚·ãƒ¥ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
å§”ä»»å…ˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€`nonce`ã€æœ‰åŠ¹æœŸé™ã‚’å«ã‚€æƒ…å ±ã‚’ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦ç”Ÿæˆã•ã‚Œã¾ã™ã€‚
3. `digest`ã¯ã€ç½²åãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å…¨ä½“ã®ãƒãƒƒã‚·ãƒ¥ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
ã“ã‚Œã¯ã€ç½²åãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¨ä»–ã®ãƒãƒƒã‚·ãƒ¥æƒ…å ±ã‚’çµ„ã¿åˆã‚ã›ã¦ç”Ÿæˆã•ã‚Œã¾ã™ã€‚
4. `ecrecover`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã€ç½²åã‹ã‚‰å¾©å…ƒã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
5. ç½²åãŒæœ‰åŠ¹ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚
6. ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®`nonce`ãŒæ­£ã—ã„ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚
7. ç¾åœ¨ã®æ™‚é–“ãŒæœ‰åŠ¹æœŸé™ã‚’è¶…ãˆã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚
8. `_delegate`é–¢æ•°ã«å‡¦ç†ã‚’å§”è­²ã—ã¦ã€å®Ÿéš›ã®å§”ä»»å‡¦ç†ã‚’è¡Œã„ã¾ã™ã€‚

### _delegate

```solidity
function _delegate(address delegator, address delegatee) internal {
        address currentDelegate = delegates[delegator];
        uint96 delegatorBalance = balances[delegator];
        delegates[delegator] = delegatee;

        emit DelegateChanged(delegator, currentDelegate, delegatee);

        _moveDelegates(currentDelegate, delegatee, delegatorBalance);
}
```

æŠ•ç¥¨ã®å§”ä»»ã‚’è¡Œã†ãŸã‚ã®é‡è¦ãªã‚¹ãƒ†ãƒƒãƒ—ã‚’å‡¦ç†ã™ã‚‹é–¢æ•°ã€‚
`delegator`ãŒå§”ä»»ã™ã‚‹å´ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã‚ã‚Šã€`delegatee`ãŒæŠ•ç¥¨ã‚’å§”ä»»ã•ã‚Œã‚‹å´ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚

1. `currentDelegate`ã¯ã€ç¾åœ¨ã®å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ ¼ç´ã™ã‚‹å¤‰æ•°ã§ã™ã€‚
`delegator`ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å§”ä»»å…ˆã‚’å–å¾—ã—ã¾ã™ã€‚
2. `delegatorBalance`ã¯ã€å§”ä»»å…ƒã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æ®‹é«˜ã‚’æ ¼ç´ã™ã‚‹å¤‰æ•°ã§ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€å§”ä»»å…ƒã®æ®‹é«˜ãŒå–å¾—ã•ã‚Œã¾ã™ã€‚
3. `delegator`ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å§”ä»»å…ˆã‚’ `delegatee`ã‚¢ãƒ‰ãƒ¬ã‚¹ã«è¨­å®šã—ã¾ã™ã€‚
`delegator`ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æŠ•ç¥¨æ¨©ã‚’ `delegatee`ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«å§”ä»»ã™ã‚‹æ“ä½œã§ã™ã€‚
4. `DelegateChanged`ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œã—ã¾ã™ã€‚
ã“ã®ã‚¤ãƒ™ãƒ³ãƒˆã¯ã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆé–“ã®æŠ•ç¥¨æ¨©ã®å§”ä»»ãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã«é€šçŸ¥ã‚’æä¾›ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
`delegator`ã‚¢ãƒ‰ãƒ¬ã‚¹ã€ä»¥å‰ã®å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ (`currentDelegate`)ã€æ–°ã—ã„å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ (`delegatee`) ãŒã‚¤ãƒ™ãƒ³ãƒˆã«å«ã¾ã‚Œã¾ã™ã€‚
5. `_moveDelegates`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€å§”ä»»å…ˆã®å¤‰æ›´ã«ä¼´ã†æŠ•ç¥¨æ•°ã®ç§»å‹•ã‚’å‡¦ç†ã—ã¾ã™ã€‚
ä»¥å‰ã®å§”ä»»å…ˆ (`currentDelegate`)ã€æ–°ã—ã„å§”ä»»å…ˆ (`delegatee`)ã€ãŠã‚ˆã³å§”ä»»å…ƒã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æ®‹é«˜ (`delegatorBalance`) ã‚’å¼•æ•°ã¨ã—ã¦æ¸¡ã—ã¾ã™ã€‚

### _moveDelegates

```solidity
function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {
        if (srcRep != dstRep && amount > 0) {
            if (srcRep != address(0)) {
                uint32 srcRepNum = numCheckpoints[srcRep];
                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;
                uint96 srcRepNew = sub96(srcRepOld, amount, "Uni::_moveVotes: vote amount underflows");
                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
            }

            if (dstRep != address(0)) {
                uint32 dstRepNum = numCheckpoints[dstRep];
                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;
                uint96 dstRepNew = add96(dstRepOld, amount, "Uni::_moveVotes: vote amount overflows");
                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
            }
        }
}
```

æŠ•ç¥¨æ¨©ã®ç§»å‹•ã‚’å‡¦ç†ã—ã€æ–°ã—ã„å§”ä»»å…ˆã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«æŠ•ç¥¨æ•°ã‚’è¿½åŠ ã—ã€å…ƒã®å§”ä»»å…ˆã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‹ã‚‰æŠ•ç¥¨æ•°ã‚’æ¸›å°‘ã•ã›ã‚‹é–¢æ•°ã€‚
`srcRep`ã¯å…ƒã®å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã€`dstRep`ã¯æ–°ã—ã„å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã€`amount`ã¯ç§»å‹•ã™ã‚‹æŠ•ç¥¨æ•°ã‚’ç¤ºã—ã¾ã™ã€‚

1. å…ƒã®å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã¨æ–°ã—ã„å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ãŒç•°ãªã‚‹å ´åˆã‹ã¤ç§»å‹•ã™ã‚‹æŠ•ç¥¨æ•°ãŒ`0`ã‚ˆã‚Šå¤§ãã„å ´åˆã«ã®ã¿ã€æ¬¡ã®å‡¦ç†ã«ç§»ã‚Šã¾ã™ã€‚
2. å…ƒã®å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ãŒã‚¼ãƒ­ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ãªã„å ´åˆã«ã€å…ƒã®å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã®æŠ•ç¥¨æ•°ã‚’å‡¦ç†ã—ã¾ã™ã€‚
3. `srcRepNum`ã¯ã€å…ƒã®å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®æ•°ã‚’ç¤ºã™å¤‰æ•°ã§ã™ã€‚
4. `srcRepOld`ã¯ã€å…ƒã®å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã®æœ€æ–°ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã§ã®æŠ•ç¥¨æ•°ã‚’ç¤ºã—ã¾ã™ã€‚
ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§`0`ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
5. `srcRepNew`ã¯ã€å…ƒã®å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã®æ–°ã—ã„ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã§ã®æŠ•ç¥¨æ•°ã‚’ç¤ºã—ã¾ã™ã€‚
`amount`ã‚’æ¸›ç®—ã™ã‚‹ã“ã¨ã§ã€æŠ•ç¥¨æ•°ãŒæ›´æ–°ã•ã‚Œã¾ã™ã€‚
æ¸›ç®—ã®éš›ã«ã‚¢ãƒ³ãƒ€ãƒ¼ãƒ•ãƒ­ãƒ¼ãŒç™ºç”Ÿã™ã‚‹å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã¨ã—ã¦å‡¦ç†ã•ã‚Œã¾ã™ã€‚
6. `_writeCheckpoint`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€å…ƒã®å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’æ›´æ–°ã—ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€å…ƒã®å§”ä»»å…ˆã®æŠ•ç¥¨æ•°ã®å¤‰æ›´ãŒè¨˜éŒ²ã•ã‚Œã¾ã™ã€‚
7. 3~6ã®æ‰‹é †ã§ã€æ–°ã—ã„å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã«å¯¾ã—ã¦ã‚‚ã€æŠ•ç¥¨æ•°ã®å¢—åŠ ã‚’å‡¦ç†ã™ã‚‹ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã™ã€‚

### _writeCheckpoint

```solidity
function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {
      uint32 blockNumber = safe32(block.number, "Uni::_writeCheckpoint: block number exceeds 32 bits");

      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {
          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
      } else {
          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);
          numCheckpoints[delegatee] = nCheckpoints + 1;
      }

      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
}
```

å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã®æŠ•ç¥¨æ•°ã®å¤‰æ›´ã‚’ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã¨ã—ã¦è¨˜éŒ²ã™ã‚‹é–¢æ•°ã€‚
`delegatee`ã¯å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã€`nCheckpoints`ã¯å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆæ•°ã€`oldVotes`ã¯å¤‰æ›´å‰ã®æŠ•ç¥¨æ•°ã€`newVotes`ã¯å¤‰æ›´å¾Œã®æŠ•ç¥¨æ•°ã§ã™ã€‚

1. `blockNumber`ã¯ã€ç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ã‚’è¡¨ã™å¤‰æ•°ã§ã™ã€‚
32ãƒ“ãƒƒãƒˆã‚’è¶…ãˆã‚‹å ´åˆã«ã‚¨ãƒ©ãƒ¼ã‚’å›é¿ã™ã‚‹ãŸã‚ã« `safe32`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ã‚’åˆ¶ç´„ã—ã¦ã„ã¾ã™ã€‚
2. ã™ã§ã«å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã®æœ€æ–°ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆãŒç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ã¨ä¸€è‡´ã—ã¦ã„ã‚‹å ´åˆã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã„ã¾ã™ã€‚
ã‚‚ã—ä¸€è‡´ã—ã¦ã„ã‚‹å ´åˆã€æœ€æ–°ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®æŠ•ç¥¨æ•°ã‚’`newVotes`ã«æ›´æ–°ã—ã¾ã™ã€‚
3. æœ€æ–°ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã®æŠ•ç¥¨æ•°ã‚’`newVotes`ã«æ›´æ–°ã—ã¾ã™ã€‚
4. æ¡ä»¶ã«å½“ã¦ã¯ã¾ã‚‰ãªã„å ´åˆã€æ–°ã—ã„ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’ä½œæˆã—ã€æ–°ã—ã„æŠ•ç¥¨æ•°ã¨ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ã‚’è¨˜éŒ²ã—ã¾ã™ã€‚
5. æ–°ã—ã„ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã‚’`checkpoints`ãƒãƒƒãƒ”ãƒ³ã‚°ã«è¿½åŠ ã—ã¾ã™ã€‚
ã“ã®æ–°ã—ã„ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆã¯ã€æ–°ã—ã„æŠ•ç¥¨æ•°ã¨ç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ã‹ã‚‰æ§‹æˆã•ã‚Œã¾ã™ã€‚
6. `numCheckpoints`ãƒãƒƒãƒ”ãƒ³ã‚°å†…ã®å§”ä»»å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆæ•°ã‚’æ›´æ–°ã—ã¾ã™ã€‚
7. æŠ•ç¥¨æ•°ãŒå¤‰æ›´ã•ã‚ŒãŸã“ã¨ã‚’ç¤ºã™ DelegateVotesChanged ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œã—ã¾ã™ã€‚

# Event

## MinterChanged

```solidity
event MinterChanged(address minter, address newMinter);
```

Mintæ¨©é™ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãã«ç™ºè¡Œã•ã‚Œã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã€‚

- `minter`
	- å¤‰æ›´å‰ã®Mintæ¨©é™ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `newMinter`
	- å¤‰æ›´å¾Œã®Mintæ¨©é™ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚

## DelegateChanged

```solidity
event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
```

ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒãã®ãƒ‡ãƒªã‚²ãƒ¼ãƒˆã‚’å¤‰æ›´ã—ãŸã¨ãã«ç™ºè¡Œã•ã‚Œã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã€‚

- `delegator`
	- ãƒ‡ãƒªã‚²ãƒ¼ãƒˆã‚’å¤‰æ›´ã—ãŸã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `fromDelegate`
	- å¤‰æ›´å‰ã®ãƒ‡ãƒªã‚²ãƒ¼ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `toDelegate`
	- æ–°ã—ã„ãƒ‡ãƒªã‚²ãƒ¼ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚

## DelegateVotesChanged

```solidity
event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);
```

ãƒ‡ãƒªã‚²ãƒ¼ãƒˆã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æŠ•ç¥¨ãƒãƒ©ãƒ³ã‚¹ãŒå¤‰æ›´ã•ã‚ŒãŸã¨ãç™ºè¡Œã•ã‚Œã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã€‚

- `delegate`
	- æŠ•ç¥¨ãƒãƒ©ãƒ³ã‚¹ãŒå¤‰æ›´ã•ã‚ŒãŸãƒ‡ãƒªã‚²ãƒ¼ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `previousBalance`
	- å¤‰æ›´å‰ã®æŠ•ç¥¨ãƒãƒ©ãƒ³ã‚¹ã€‚
- `newBalance`
	- æ–°ã—ã„æŠ•ç¥¨ãƒãƒ©ãƒ³ã‚¹ã€‚

# ã‚³ãƒ¼ãƒ‰

## SafeMath

:::details SafeMath
```solidity
/**
 *Submitted for verification at Etherscan.io on 2020-09-15
*/

pragma solidity ^0.5.16;
pragma experimental ABIEncoderV2;

// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol
// Subject to the MIT license.

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, errorMessage);

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot underflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction underflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot underflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, errorMessage);

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers.
     * Reverts on division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers.
     * Reverts with custom message on division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}
```
:::

## Uni

:::details Uni
```solidity
/**
 *Submitted for verification at Etherscan.io on 2020-09-15
*/

pragma solidity ^0.5.16;
pragma experimental ABIEncoderV2;

// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol
// Subject to the MIT license.

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */
library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, errorMessage);

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot underflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction underflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot underflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, errorMessage);

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers.
     * Reverts on division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers.
     * Reverts with custom message on division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

contract Uni {
    /// @notice EIP-20 token name for this token
    string public constant name = "Uniswap";

    /// @notice EIP-20 token symbol for this token
    string public constant symbol = "UNI";

    /// @notice EIP-20 token decimals for this token
    uint8 public constant decimals = 18;

    /// @notice Total number of tokens in circulation
    uint public totalSupply = 1_000_000_000e18; // 1 billion Uni

    /// @notice Address which may mint new tokens
    address public minter;

    /// @notice The timestamp after which minting may occur
    uint public mintingAllowedAfter;

    /// @notice Minimum time between mints
    uint32 public constant minimumTimeBetweenMints = 1 days * 365;

    /// @notice Cap on the percentage of totalSupply that can be minted at each mint
    uint8 public constant mintCap = 2;

    /// @notice Allowance amounts on behalf of others
    mapping (address => mapping (address => uint96)) internal allowances;

    /// @notice Official record of token balances for each account
    mapping (address => uint96) internal balances;

    /// @notice A record of each accounts delegate
    mapping (address => address) public delegates;

    /// @notice A checkpoint for marking number of votes from a given block
    struct Checkpoint {
        uint32 fromBlock;
        uint96 votes;
    }

    /// @notice A record of votes checkpoints for each account, by index
    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;

    /// @notice The number of checkpoints for each account
    mapping (address => uint32) public numCheckpoints;

    /// @notice The EIP-712 typehash for the contract's domain
    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");

    /// @notice The EIP-712 typehash for the delegation struct used by the contract
    bytes32 public constant DELEGATION_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");

    /// @notice The EIP-712 typehash for the permit struct used by the contract
    bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");

    /// @notice A record of states for signing / validating signatures
    mapping (address => uint) public nonces;

    /// @notice An event thats emitted when the minter address is changed
    event MinterChanged(address minter, address newMinter);

    /// @notice An event thats emitted when an account changes its delegate
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);

    /// @notice An event thats emitted when a delegate account's vote balance changes
    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);

    /// @notice The standard EIP-20 transfer event
    event Transfer(address indexed from, address indexed to, uint256 amount);

    /// @notice The standard EIP-20 approval event
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    /**
     * @notice Construct a new Uni token
     * @param account The initial account to grant all the tokens
     * @param minter_ The account with minting ability
     * @param mintingAllowedAfter_ The timestamp after which minting may occur
     */
    constructor(address account, address minter_, uint mintingAllowedAfter_) public {
        require(mintingAllowedAfter_ >= block.timestamp, "Uni::constructor: minting can only begin after deployment");

        balances[account] = uint96(totalSupply);
        emit Transfer(address(0), account, totalSupply);
        minter = minter_;
        emit MinterChanged(address(0), minter);
        mintingAllowedAfter = mintingAllowedAfter_;
    }

    /**
     * @notice Change the minter address
     * @param minter_ The address of the new minter
     */
    function setMinter(address minter_) external {
        require(msg.sender == minter, "Uni::setMinter: only the minter can change the minter address");
        emit MinterChanged(minter, minter_);
        minter = minter_;
    }

    /**
     * @notice Mint new tokens
     * @param dst The address of the destination account
     * @param rawAmount The number of tokens to be minted
     */
    function mint(address dst, uint rawAmount) external {
        require(msg.sender == minter, "Uni::mint: only the minter can mint");
        require(block.timestamp >= mintingAllowedAfter, "Uni::mint: minting not allowed yet");
        require(dst != address(0), "Uni::mint: cannot transfer to the zero address");

        // record the mint
        mintingAllowedAfter = SafeMath.add(block.timestamp, minimumTimeBetweenMints);

        // mint the amount
        uint96 amount = safe96(rawAmount, "Uni::mint: amount exceeds 96 bits");
        require(amount <= SafeMath.div(SafeMath.mul(totalSupply, mintCap), 100), "Uni::mint: exceeded mint cap");
        totalSupply = safe96(SafeMath.add(totalSupply, amount), "Uni::mint: totalSupply exceeds 96 bits");

        // transfer the amount to the recipient
        balances[dst] = add96(balances[dst], amount, "Uni::mint: transfer amount overflows");
        emit Transfer(address(0), dst, amount);

        // move delegates
        _moveDelegates(address(0), delegates[dst], amount);
    }

    /**
     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`
     * @param account The address of the account holding the funds
     * @param spender The address of the account spending the funds
     * @return The number of tokens approved
     */
    function allowance(address account, address spender) external view returns (uint) {
        return allowances[account][spender];
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint rawAmount) external returns (bool) {
        uint96 amount;
        if (rawAmount == uint(-1)) {
            amount = uint96(-1);
        } else {
            amount = safe96(rawAmount, "Uni::approve: amount exceeds 96 bits");
        }

        allowances[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /**
     * @notice Triggers an approval from owner to spends
     * @param owner The address to approve from
     * @param spender The address to be approved
     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)
     * @param deadline The time at which to expire the signature
     * @param v The recovery byte of the signature
     * @param r Half of the ECDSA signature pair
     * @param s Half of the ECDSA signature pair
     */
    function permit(address owner, address spender, uint rawAmount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
        uint96 amount;
        if (rawAmount == uint(-1)) {
            amount = uint96(-1);
        } else {
            amount = safe96(rawAmount, "Uni::permit: amount exceeds 96 bits");
        }

        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));
        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, rawAmount, nonces[owner]++, deadline));
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
        address signatory = ecrecover(digest, v, r, s);
        require(signatory != address(0), "Uni::permit: invalid signature");
        require(signatory == owner, "Uni::permit: unauthorized");
        require(now <= deadline, "Uni::permit: signature expired");

        allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);
    }

    /**
     * @notice Get the number of tokens held by the `account`
     * @param account The address of the account to get the balance of
     * @return The number of tokens held
     */
    function balanceOf(address account) external view returns (uint) {
        return balances[account];
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param rawAmount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint rawAmount) external returns (bool) {
        uint96 amount = safe96(rawAmount, "Uni::transfer: amount exceeds 96 bits");
        _transferTokens(msg.sender, dst, amount);
        return true;
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param rawAmount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {
        address spender = msg.sender;
        uint96 spenderAllowance = allowances[src][spender];
        uint96 amount = safe96(rawAmount, "Uni::approve: amount exceeds 96 bits");

        if (spender != src && spenderAllowance != uint96(-1)) {
            uint96 newAllowance = sub96(spenderAllowance, amount, "Uni::transferFrom: transfer amount exceeds spender allowance");
            allowances[src][spender] = newAllowance;

            emit Approval(src, spender, newAllowance);
        }

        _transferTokens(src, dst, amount);
        return true;
    }

    /**
     * @notice Delegate votes from `msg.sender` to `delegatee`
     * @param delegatee The address to delegate votes to
     */
    function delegate(address delegatee) public {
        return _delegate(msg.sender, delegatee);
    }

    /**
     * @notice Delegates votes from signatory to `delegatee`
     * @param delegatee The address to delegate votes to
     * @param nonce The contract state required to match the signature
     * @param expiry The time at which to expire the signature
     * @param v The recovery byte of the signature
     * @param r Half of the ECDSA signature pair
     * @param s Half of the ECDSA signature pair
     */
    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {
        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));
        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
        address signatory = ecrecover(digest, v, r, s);
        require(signatory != address(0), "Uni::delegateBySig: invalid signature");
        require(nonce == nonces[signatory]++, "Uni::delegateBySig: invalid nonce");
        require(now <= expiry, "Uni::delegateBySig: signature expired");
        return _delegate(signatory, delegatee);
    }

    /**
     * @notice Gets the current votes balance for `account`
     * @param account The address to get votes balance
     * @return The number of current votes for `account`
     */
    function getCurrentVotes(address account) external view returns (uint96) {
        uint32 nCheckpoints = numCheckpoints[account];
        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;
    }

    /**
     * @notice Determine the prior number of votes for an account as of a block number
     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.
     * @param account The address of the account to check
     * @param blockNumber The block number to get the vote balance at
     * @return The number of votes the account had as of the given block
     */
    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {
        require(blockNumber < block.number, "Uni::getPriorVotes: not yet determined");

        uint32 nCheckpoints = numCheckpoints[account];
        if (nCheckpoints == 0) {
            return 0;
        }

        // First check most recent balance
        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nCheckpoints - 1].votes;
        }

        // Next check implicit zero balance
        if (checkpoints[account][0].fromBlock > blockNumber) {
            return 0;
        }

        uint32 lower = 0;
        uint32 upper = nCheckpoints - 1;
        while (upper > lower) {
            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow
            Checkpoint memory cp = checkpoints[account][center];
            if (cp.fromBlock == blockNumber) {
                return cp.votes;
            } else if (cp.fromBlock < blockNumber) {
                lower = center;
            } else {
                upper = center - 1;
            }
        }
        return checkpoints[account][lower].votes;
    }

    function _delegate(address delegator, address delegatee) internal {
        address currentDelegate = delegates[delegator];
        uint96 delegatorBalance = balances[delegator];
        delegates[delegator] = delegatee;

        emit DelegateChanged(delegator, currentDelegate, delegatee);

        _moveDelegates(currentDelegate, delegatee, delegatorBalance);
    }

    function _transferTokens(address src, address dst, uint96 amount) internal {
        require(src != address(0), "Uni::_transferTokens: cannot transfer from the zero address");
        require(dst != address(0), "Uni::_transferTokens: cannot transfer to the zero address");

        balances[src] = sub96(balances[src], amount, "Uni::_transferTokens: transfer amount exceeds balance");
        balances[dst] = add96(balances[dst], amount, "Uni::_transferTokens: transfer amount overflows");
        emit Transfer(src, dst, amount);

        _moveDelegates(delegates[src], delegates[dst], amount);
    }

    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {
        if (srcRep != dstRep && amount > 0) {
            if (srcRep != address(0)) {
                uint32 srcRepNum = numCheckpoints[srcRep];
                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;
                uint96 srcRepNew = sub96(srcRepOld, amount, "Uni::_moveVotes: vote amount underflows");
                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
            }

            if (dstRep != address(0)) {
                uint32 dstRepNum = numCheckpoints[dstRep];
                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;
                uint96 dstRepNew = add96(dstRepOld, amount, "Uni::_moveVotes: vote amount overflows");
                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {
      uint32 blockNumber = safe32(block.number, "Uni::_writeCheckpoint: block number exceeds 32 bits");

      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {
          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
      } else {
          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);
          numCheckpoints[delegatee] = nCheckpoints + 1;
      }

      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);
    }

    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {
        require(n < 2**32, errorMessage);
        return uint32(n);
    }

    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {
        require(n < 2**96, errorMessage);
        return uint96(n);
    }

    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {
        uint96 c = a + b;
        require(c >= a, errorMessage);
        return c;
    }

    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {
        require(b <= a, errorMessage);
        return a - b;
    }

    function getChainId() internal pure returns (uint) {
        uint256 chainId;
        assembly { chainId := chainid() }
        return chainId;
    }
}
```
:::


# æœ€å¾Œã«

ä»Šå›ã®è¨˜äº‹ã§ã¯ã€Bunzzã®æ–°æ©Ÿèƒ½ã€DeCipherã€ã‚’ä½¿ç”¨ã—ã¦ã€Uniswapã®ã€Œ**Uni**ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’è¦‹ã¦ãã¾ã—ãŸã€‚
ã„ã‹ãŒã ã£ãŸã§ã—ã‚‡ã†ã‹ï¼Ÿ
ä»Šå¾Œã‚‚ç‰¹å®šã®NFTã‚„ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ãƒ”ãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã¦ã¾ã¨ã‚ã¦è¡ŒããŸã„ã¨æ€ã„ã¾ã™ã€‚

æ™®æ®µã¯ãƒ–ãƒ­ã‚°ã‚„Qiitaã§ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚„AIã«é–¢ã™ã‚‹è¨˜äº‹ã‚’æŒ™ã’ã¦ã„ã‚‹ã®ã§ã€ã‚ˆã‘ã‚Œã°è¦‹ã¦ã„ã£ã¦ãã ã•ã„ï¼

https://chaldene.net/

https://qiita.com/cardene
