---
title: "[Bunzz Decipher] UniswapV2Router01ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ç†è§£ã—ã‚ˆã†ï¼"
emoji: "ðŸ¦„"
type: "tech"
topics:
  - "blockchain"
  - "ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³"
  - "solidity"
  - "ethereum"
  - "defi"
published: true
published_at: "2023-08-14 07:02"
publication_name: "cryptogames"
---

# ã¯ã˜ã‚ã«

åˆã‚ã¾ã—ã¦ã€‚
**CryptoGames**ã¨ã„ã†ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚²ãƒ¼ãƒ ä¼æ¥­ã§ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã‚’ã—ã¦ã„ã‚‹ **cardeneï¼ˆã‹ã‚‹ã§ã­ï¼‰** ã§ã™ï¼
ã‚¹ãƒžãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’æ›¸ã„ãŸã‚Šã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ»ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ»ã‚¤ãƒ³ãƒ•ãƒ©ã¨å¹…åºƒãè§¦ã‚Œã¦ã„ã¾ã™ã€‚

https://cryptogames.co.jp/

ä»£è¡¨çš„ãªã‚²ãƒ¼ãƒ ã¯**ã‚¯ãƒªãƒ—ãƒˆã‚¹ãƒšãƒ«ã‚º**ã¨ã„ã†ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚²ãƒ¼ãƒ ã§ã™ã€‚

https://cryptospells.jp/

ä»Šå›žã¯Bunzzã®æ–°æ©Ÿèƒ½ã€Ž**DeCipher**ã€ã‚’ä½¿ç”¨ã—ã¦ã€UniswapV2ã®ã€Œ**UniswapV2Router01**ã€ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’è¦‹ã¦ã¿ã‚ˆã†ã¨æ€ã„ã¾ã™ã€‚

:::message alert
å…¬å¼ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã‚‚æ›¸ã‹ã‚Œã¦ã„ã‚‹ã‚ˆã†ã«ã€**UniswapV2Router01**ã¯éžæŽ¨å¥¨ã«ãªã£ã¦ãŠã‚Šã€**UniswapV2Router02**ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒæŽ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ã€‚

> UniswapV2Router01 should not be used any longer, because of the discovery of a low severity bug and the fact that some methods do not work with tokens that take fees on transfer. The current recommendation is to use UniswapV2Router02.
:::

ã€Ž**DeCipher**ã€ã¯AIã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’è‡ªå‹•ç”Ÿæˆã—ã¦ãã‚Œã‚‹ã‚µãƒ¼ãƒ“ã‚¹ã§ã™ã€‚

https://www.bunzz.dev/decipher

è©³ã—ã„ä½¿ã„æ–¹ã«é–¢ã—ã¦ã¯ä»¥ä¸‹ã®è¨˜äº‹ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ï¼

https://zenn.dev/heku/articles/33266f0c19d523

:::message
ã“ã®è¨˜äº‹ã¯ã‚ãã¾ã§å€‹äººãŒã€Œ**DeCipher**ã€ã‚’ä½¿ç”¨ã—ã¦ã¿ã¦ã®è¨˜äº‹ã«ãªã‚Šã¾ã™ã€‚
é–“é•ã£ãŸéƒ¨åˆ†ãªã©ã‚‚ã‚ã‚‹ã‹ã¨æ€ã„ã¾ã™ãŒã€ãã®éš›ã¯ã‚³ãƒ¡ãƒ³ãƒˆãªã©ã§æ•™ãˆã¦ãã ã•ã„ã€‚
:::

ä»Šå›žä½¿ç”¨ã™ã‚‹ã€Ž**DeCipher**ã€ã®ãƒªãƒ³ã‚¯ã¯ä»¥ä¸‹ã«ãªã‚Šã¾ã™ã€‚

https://app.bunzz.dev/decipher/chains/1/addresses/0xf164fC0Ec4E93095b804a4795bBe1e041497b92a

# æ¦‚è¦

**UniswapV2Router01**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€Ethereumãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ä¸Šã«æ§‹ç¯‰ã•ã‚ŒãŸåˆ†æ•£åž‹å–å¼•æ‰€ï¼ˆDEXï¼‰ã§ã‚ã‚‹Uniswapãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®é‡è¦ãªéƒ¨åˆ†ã§ã™ã€‚
ã“ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€**Uniswap**å–å¼•æ‰€ã¸ã®æµå‹•æ€§ã®è¿½åŠ ã‚„ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¹ãƒ¯ãƒƒãƒ—ã‚’ä¿ƒé€²ã™ã‚‹å½¹å‰²ã‚’æžœãŸã—ã¦ã„ã¾ã™ã€‚
**Uniswap**ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ã®éµã¨ãªã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§ã‚ã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨å®‰å…¨ã‹ã¤æ¨™æº–çš„ãªæ–¹æ³•ã§ã‚„ã‚Šå–ã‚Šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

## ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ç›®çš„
**UniswapV2Router01**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ä¸»ãªç›®çš„ã¯ã€**Uniswap**ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã‚„ã‚Šå–ã‚Šã™ã‚‹ãŸã‚ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã™ã€‚
ã“ã‚Œã«ã¯ã€å–å¼•æ‰€ã¸ã®æµå‹•æ€§ã®è¿½åŠ ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¹ãƒ¯ãƒƒãƒ—ã€æµå‹•æ€§ã®å¼•ãå‡ºã—ãŒå«ã¾ã‚Œã¾ã™ã€‚
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯æŸ”è»Ÿã§é©å¿œåŠ›ãŒã‚ã‚Šã€**Uniswap**ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ å†…ã§ã•ã¾ã–ã¾ãªãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã§ãã‚‹ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚

## ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®è²¬ä»»
**UniswapV2Router01**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«ã¯ã„ãã¤ã‹ã®ä¸»ãªè²¬ä»»ãŒã‚ã‚Šã¾ã™ã€‚

### æµå‹•æ€§ã®è¿½åŠ 
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€**Uniswap**å–å¼•æ‰€ã«æµå‹•æ€§ã‚’è¿½åŠ ã™ã‚‹ãŸã‚ã®é–¢æ•°ã‚’æä¾›ã—ã¾ã™ã€‚
ã“ã‚Œã«ã¯ã€ç‰¹å®šã®æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã«ä¸€å¯¾ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’é ã‘ã‚‹ã“ã¨ãŒå«ã¾ã‚Œã¾ã™ã€‚
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€æ­£ã—ã„é‡ã®å„ãƒˆãƒ¼ã‚¯ãƒ³ãŒé ã‘ã‚‰ã‚Œã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒæ­£ã—ãå‡¦ç†ã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

### ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¹ãƒ¯ãƒƒ
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¹ãƒ¯ãƒƒãƒ—ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚
ã“ã‚Œã«ã¯ã€ç¾åœ¨ã®æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã®äº¤æ›ãƒ¬ãƒ¼ãƒˆã«åŸºã¥ã„ã¦ã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚’äº¤æ›ã™ã‚‹ã“ã¨ãŒå«ã¾ã‚Œã¾ã™ã€‚
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€ã‚¹ãƒ¯ãƒƒãƒ—ãŒæ­£ã—ãå®Ÿè¡Œã•ã‚Œã€æ­£ã—ã„é‡ã®å„ãƒˆãƒ¼ã‚¯ãƒ³ãŒè»¢é€ã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

### æµå‹•æ€§ã®å¼•ãå‡ºã—
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå–å¼•æ‰€ã‹ã‚‰æµå‹•æ€§ã‚’å¼•ãå‡ºã™ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚
ã“ã‚Œã«ã¯ã€ç‰¹å®šã®é‡ã®æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ—ãƒ¼ãƒ«ã‹ã‚‰å–ã‚Šå‡ºã—ã€ãã®ä»£ã‚ã‚Šã«åŸºã«ãªã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å—ã‘å–ã‚‹ã“ã¨ãŒå«ã¾ã‚Œã¾ã™ã€‚
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€å¼•ãå‡ºã—ãŒæ­£ã—ãå‡¦ç†ã•ã‚Œã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ­£ã—ã„é‡ã®å„ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å—ã‘å–ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

### ERC20ãƒˆãƒ¼ã‚¯ãƒ³ã¨ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€Ethereumãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã§ä½¿ç”¨ã•ã‚Œã‚‹æ¨™æº–çš„ãªã‚¿ã‚¤ãƒ—ã®ãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚ã‚‹ERC20ãƒˆãƒ¼ã‚¯ãƒ³ã¨ã‚„ã‚Šå–ã‚Šã—ã¾ã™ã€‚
ã“ã‚Œã«ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®è»¢é€ã€å¼•ãå‡ºã—ã®ãŸã‚ã®æ‰¿èªã€ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®æ®‹é«˜ã®ç¢ºèªãŒå«ã¾ã‚Œã¾ã™ã€‚

### ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®å¦¥å½“æ€§ã®ç¢ºä¿
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«ã¯ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒå¦¥å½“ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã®ã„ãã¤ã‹ã®ã‚»ãƒ¼ãƒ•ã‚¬ãƒ¼ãƒ‰ãŒçµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã™ã€‚
ã“ã‚Œã«ã¯ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®æœŸé™ãŒéŽãŽã¦ã„ãªã„ã“ã¨ã®ç¢ºèªã‚„ã€æ­£ã—ã„é‡ã®ãƒˆãƒ¼ã‚¯ãƒ³ãŒè»¢é€ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã®ç¢ºèªãŒå«ã¾ã‚Œã¾ã™ã€‚

:::message
ã¾ã¨ã‚ã‚‹ã¨ã€**UniswapV2Router01**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯Uniswapãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®é‡è¦ãªéƒ¨åˆ†ã§ã‚ã‚Šã€å–å¼•æ‰€ã¨ã‚„ã‚Šå–ã‚Šã™ã‚‹ãŸã‚ã®å®‰å…¨ã§æ¨™æº–åŒ–ã•ã‚ŒãŸã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚
ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒæ­£ã—ãå‡¦ç†ã•ã‚Œã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå®‰å…¨ãªæ–¹æ³•ã§æµå‹•æ€§ã‚’è¿½åŠ ã—ã€å¼•ãå‡ºã™ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ä¿è¨¼ã—ã¾ã™ã€‚
:::

# ä½¿ã„æ–¹

**UniswapV2Router01**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€**Uniswap**ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ä¸€éƒ¨ã§ã‚ã‚Šã€Ethereumãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ä¸Šã®ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ä¸å¯èƒ½ãªã‚¹ãƒžãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚·ã‚¹ãƒ†ãƒ ã«å®Ÿè£…ã•ã‚ŒãŸã€å®šæ•°ç©ç®—å¼ã«åŸºã¥ãè‡ªå‹•æµå‹•æ€§ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚
ã“ã‚Œã¯é«˜åº¦ã«åˆ†æ•£åŒ–ã•ã‚Œã€æ“ä½œå¯èƒ½ãªé‡‘èžåŸºç›¤ã‚’æä¾›ã—ã€èª°ã§ã‚‚åˆ†æ•£åŒ–ã•ã‚ŒãŸæ–¹æ³•ã§æ–°ã—ã„é‡‘èžå¸‚å ´ã‚’ä½œæˆã§ãã‚‹ä¸–ç•Œã‚’ç›®æŒ‡ã—ã¦ã„ã¾ã™ã€‚

:::message
å®šæ•°ç©ç®—å¼ã«åŸºã¥ãè‡ªå‹•æµå‹•æ€§ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨ã¯ã€åˆ†æ•£åž‹å–å¼•æ‰€ï¼ˆDEXï¼‰ã‚„æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã®ä»•çµ„ã¿ã®ã“ã¨ã‚’æŒ‡ã—ã¾ã™ã€‚
å…·ä½“çš„ã«ã¯ã€2ã¤ã®ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆé€šå¸¸ã¯ç•°ãªã‚‹ç¨®é¡žã®ãƒˆãƒ¼ã‚¯ãƒ³ï¼‰ã‚’1å¯¾1ã§äº¤æ›ã§ãã‚‹å–å¼•æ‰€ã‚„æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ãŒã‚ã‚Šã¾ã™ã€‚
ã“ã“ã§é‡è¦ãªã®ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³Aã¨ãƒˆãƒ¼ã‚¯ãƒ³Bã®ç©ï¼ˆãƒãƒ©ãƒ³ã‚¹ï¼‰ãŒå¸¸ã«ä¸€å®šã§ã‚ã‚‹ã“ã¨ã§ã™ã€‚
ä¾‹ãˆã°ã€ãƒˆãƒ¼ã‚¯ãƒ³Aã¨ãƒˆãƒ¼ã‚¯ãƒ³Bã®ãƒãƒ©ãƒ³ã‚¹ãŒãã‚Œãžã‚Œ10ã¨100ã®å ´åˆã€ãã®ç©ã¯1,000ã§ã™ã€‚ã“ã®æ•°å€¤ã¯å¤‰ã‚ã‚Šã¾ã›ã‚“ã€‚

ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒˆãƒ¼ã‚¯ãƒ³Aã‚’ãƒˆãƒ¼ã‚¯ãƒ³Bã«äº¤æ›ã™ã‚‹ã¨ã€ãƒˆãƒ¼ã‚¯ãƒ³Aã®ãƒãƒ©ãƒ³ã‚¹ãŒå°‘ã—æ¸›å°‘ã—ã€ãƒˆãƒ¼ã‚¯ãƒ³Bã®ãƒãƒ©ãƒ³ã‚¹ãŒå°‘ã—å¢—åŠ ã—ã¾ã™ã€‚
ã—ã‹ã—ãã®ç©ã¯å¤‰ã‚ã‚‰ãªã„ãŸã‚ã€å–å¼•ä¾¡æ ¼ã¯ãƒˆãƒ¼ã‚¯ãƒ³Aã¨ãƒˆãƒ¼ã‚¯ãƒ³Bã®ãƒãƒ©ãƒ³ã‚¹ã®æ¯”çŽ‡ã«ã‚ˆã£ã¦æ±ºã¾ã‚Šã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€å¸‚å ´ã®éœ€è¦ã¨ä¾›çµ¦ã«å¿œã˜ã¦ä¾¡æ ¼ãŒè‡ªå‹•çš„ã«èª¿æ•´ã•ã‚Œã‚‹ä»•çµ„ã¿ãŒç”Ÿã¾ã‚Œã¾ã™ã€‚

ã¾ãŸã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªåˆ†ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã«æä¾›ã™ã‚‹ã“ã¨ã§æ‰‹æ•°æ–™ã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ã“ã®ã¨ãã‚‚ã€å®šæ•°ç©ç®—å¼ãŒä¿ãŸã‚Œã‚‹ã‚ˆã†ã«ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒãƒ©ãƒ³ã‚¹ãŒé©åˆ‡ã«èª¿æ•´ã•ã‚Œã¾ã™ã€‚

ã“ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®åˆ©ç‚¹ã¯ã€å–å¼•ä¾¡æ ¼ã®å¤‰å‹•ãŒä¾›çµ¦ã¨éœ€è¦ã«å¿œã˜ã¦è‡ªå‹•çš„ã«è¡Œã‚ã‚Œã‚‹ãŸã‚ã€ãƒžãƒ¼ã‚±ãƒƒãƒˆãƒ¡ã‚¤ã‚«ãƒ¼ã‚„æµå‹•æ€§ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ãŒç¶™ç¶šçš„ã«å¸‚å ´ã‚’ç›£è¦–ã—èª¿æ•´ã™ã‚‹å¿…è¦ãŒãªã„ã“ã¨ã§ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€ã‚ˆã‚Šåˆ†æ•£åŒ–ã•ã‚ŒãŸã€åŠ¹çŽ‡çš„ãªå–å¼•ç’°å¢ƒãŒå®Ÿç¾ã•ã‚Œã¾ã™ã€‚
:::

**UniswapV2Router01**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ç›®æ¨™ã¯ã€**Uniswap V2**ãƒšã‚¢ã¨ã®ã‚„ã‚Šå–ã‚Šã‚’å®¹æ˜“ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚
æµå‹•æ€§ã®è¿½åŠ ã€æµå‹•æ€§ã®å‰Šé™¤ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¹ãƒ¯ãƒƒãƒ—ã®ãŸã‚ã®é–¢æ•°ã‚’æä¾›ã—ã¦ã„ã¾ã™ã€‚

**UniswapV2Router01**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ä½¿ç”¨ã™ã‚‹æ‰‹é †ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

### 1. ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ãƒ‡ãƒ—ãƒ­ã‚¤

**UniswapV2Router01**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’Ethereumãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ä¸Šã«ãƒ‡ãƒ—ãƒ­ã‚¤ã—ã¾ã™ã€‚
ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã¯ã€**Uniswap**ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¨**WETH**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå¿…è¦ã§ã™ã€‚

### 2. æµå‹•æ€§ã®è¿½åŠ 

`addLiquidity`ã¾ãŸã¯`addLiquidityETH`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€ãƒšã‚¢ã«æµå‹•æ€§ã‚’è¿½åŠ ã—ã¾ã™ã€‚
ã“ã®é–¢æ•°ã«ã¯ã€2ã¤ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€å„ãƒˆãƒ¼ã‚¯ãƒ³ã®å¸Œæœ›æ•°é‡ã¨æœ€å°æ•°é‡ã€æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å—ã‘å–ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€æœŸé™ãŒå¿…è¦ã§ã™ã€‚

### 3. æµå‹•æ€§ã®å‰Šé™¤

`removeLiquidity`ã¾ãŸã¯`removeLiquidityETH`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€ãƒšã‚¢ã‹ã‚‰æµå‹•æ€§ã‚’å‰Šé™¤ã—ã¾ã™ã€‚
ã“ã®é–¢æ•°ã«ã¯ã€2ã¤ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€å‰Šé™¤ã™ã‚‹æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã€å—ã‘å–ã‚‹å„ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ€å°æ•°é‡ã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å—ã‘å–ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€æœŸé™ãŒå¿…è¦ã§ã™ã€‚

### 4. ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¹ãƒ¯ãƒƒãƒ—

`swapExactTokensForTokens`ã€`swapTokensForExactTokens`ã€`swapExactETHForTokens`ã€`swapTokensForExactETH`ã€`swapExactTokensForETH`ã€`swapETHForExactTokens`ã®ã„ãšã‚Œã‹ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ã‚¹ãƒ¯ãƒƒãƒ—ã—ã¾ã™ã€‚
ã“ã‚Œã«ã¯ã€å…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã€æœ€å°ã®å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã€å…¥åŠ›ã¨å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å—ã‘å–ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€æœŸé™ãŒå¿…è¦ã§ã™ã€‚

### 5. å—ã‘å–ã£ãŸETHã®å‡¦ç†
**WETH**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‹ã‚‰å—ã‘å–ã£ãŸETHã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

:::message
ãƒˆãƒ¼ã‚¯ãƒ³ã®è»¢é€ã‚’å«ã‚€ã™ã¹ã¦ã®é–¢æ•°ã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‹ã‚‰äº‹å‰ã«æ‰¿èªã‚’å—ã‘ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ãƒˆãƒ¼ã‚¯ãƒ³ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®`approve`é–¢æ•°ã‚’ã€**UniswapV2Router01**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨æ‰¿èªã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã¨ã¨ã‚‚ã«å‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
:::

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

## _factory

**UniswapV2Factory**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã‚’ä½œæˆã—ã€æ—¢å­˜ã®ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

:::message
**UniswapV2Factory**ã«ã¤ã„ã¦ã¯ä»¥ä¸‹ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚
:::

https://zenn.dev/cryptogames/articles/89744d2e9629f4

## _WETH

**Wrapped Etherï¼ˆWETHï¼‰** ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
**Uniswap**ä¸Šã®å–å¼•ãƒšã‚¢ã®åŸºè»¸é€šè²¨ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
ã¤ã¾ã‚Šã€**WETH**ã¯Ethereumã®**ETH**ã‚’ãƒˆãƒ¼ã‚¯ãƒ³åŒ–ã—ãŸã‚‚ã®ã§ã‚ã‚Šã€**Uniswap**å†…ã§ãƒˆãƒ¼ã‚¯ãƒ³ã¨ã—ã¦å–ã‚Šæ‰±ã†ã“ã¨ãŒã§ãã¾ã™ã€‚

# å®šæ•°ãƒ»ä¿®é£¾å­

## å®šæ•°

### WETH

```solidity
address public immutable override WETH;
```

WETHãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ ¼ç´ã—ãŸå®šæ•°ã€‚

### factory

```solidity
address public immutable override factory;
```

**Factory**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ ¼ç´ã—ãŸå®šæ•°ã€‚

## ä¿®é£¾å­

### ensure

```solidity
modifier ensure(uint deadline) {
        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');
        _;
}
```

ã‚ã‚‹æ“ä½œãŒè¡Œã‚ã‚Œã‚‹å‰ã«ã€ä¸Žãˆã‚‰ã‚ŒãŸæœŸé™ï¼ˆdeadlineï¼‰ãŒã¾ã æœ‰åŠ¹ã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã€æœŸé™ãŒåˆ‡ã‚Œã¦ã„ã‚‹å ´åˆã«ã¯æ“ä½œã‚’æ‹’å¦ã™ã‚‹å½¹å‰²ã‚’æŒã¤ä¿®é£¾å­ã€‚

1. å¼•æ•°ã¨ã—ã¦æ¸¡ã•ã‚ŒãŸã€Œ`deadline`ã€ï¼ˆæœŸé™ï¼‰ã‚’ç¢ºèªã—ã¾ã™ã€‚
2. ã‚‚ã—ç¾åœ¨ã®ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆæ™‚é–“ï¼‰ãŒã€Œ`deadline`ã€ã‚ˆã‚Šã‚‚å¾Œã§ã‚ã‚Œã°ã€æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ãªã„ã¨ã¿ãªã—ã¾ã™ã€‚
3. ã‚‚ã—æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ãªã„å ´åˆã€ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¦ã€ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã€Œ**UniswapV2Router: EXPIRED**ã€ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
4. ã‚‚ã—æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹å ´åˆã€ãƒ¢ãƒ‡ã‚£ãƒ•ã‚¡ã‚¤ã‚¢å†…ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆã€Œ**_;**ã€ï¼‰ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚

# ãã®ä»–

## constructor

```solidity
constructor(address _factory, address _WETH) public {
        factory = _factory;
        WETH = _WETH;
}
```

**WETH**ã¨**Factory**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å¼•æ•°ã§å—ã‘å–ã‚Šè¨­å®šã—ã¦ã„ã¾ã™ã€‚

## receive

```solidity
receive() external payable {
        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract
}
```

**WETH**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‹ã‚‰ã®ã¿é€ä¿¡ã•ã‚ŒãŸEtherã‚’å—ã‘å…¥ã‚Œã‚‹ãŸã‚ã®ä»•çµ„ã¿ã‚’æä¾›ã—ã¾ã™ã€‚

1. å¤–éƒ¨ã‹ã‚‰**ETH**ãŒã“ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«é€ã‚‰ã‚Œã¦ããŸã¨ãã«ã€è‡ªå‹•çš„ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚
2. ã€Œ`assert`ã€æ–‡ã¯ã€æ¡ä»¶ãŒæˆç«‹ã—ãªã„å ´åˆã«ä¾‹å¤–ã‚’ç™ºç”Ÿã•ã›ã¾ã™ã€‚
ã“ã®å ´åˆã€æ¡ä»¶ã¯ã€Œ`msg.sender == WETH`ã€ã¨ãªã£ã¦ã„ã¾ã™ã€‚
3. æ¡ä»¶å¼ã€Œ`msg.sender == WETH`ã€ã¯ã€Etherã‚’é€ä¿¡ã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆé€ä¿¡è€…ï¼‰ãŒ**WETH**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã§ã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚
4. ã‚‚ã—é€ä¿¡è€…ãŒ**WETH**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã§ãªã„å ´åˆã€æ¡ä»¶ã‚’æº€ãŸã•ãªã„ã¨åˆ¤æ–­ã•ã‚Œã€ä¾‹å¤–ãŒç™ºç”Ÿã—ã¦ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãŒä¸­æ­¢ã•ã‚Œã¾ã™ã€‚
5. é€ä¿¡è€…ãŒ**WETH**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã§ã‚ã‚‹å ´åˆã€æ¡ä»¶ã‚’æº€ãŸã™ã¨åˆ¤æ–­ã•ã‚Œã€**ETH**ã®å—ã‘å…¥ã‚ŒãŒè¨±å¯ã•ã‚Œã¾ã™ã€‚


# é–¢æ•°

## READ

### getAmountIn

ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã«ãŠã„ã¦ç‰¹å®šã®å‡ºåŠ›é‡ï¼ˆ`amountOut`ï¼‰ã‚’å¾—ã‚‹ãŸã‚ã«å¿…è¦ãªå…¥åŠ›é‡ï¼ˆ`amountIn`ï¼‰ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã€‚

**å¼•æ•°**

- `amountOut`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã®ç›®æ¨™ã®å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚
- `reserveIn`
	- ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢å†…ã®å…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒªã‚¶ãƒ¼ãƒ–ï¼ˆä¿æœ‰ï¼‰é‡ã€‚
	- ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—æ™‚ã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ¸¡ã™ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚
- `reserveOut`
	- ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢å†…ã®å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒªã‚¶ãƒ¼ãƒ–ï¼ˆä¿æœ‰ï¼‰é‡ã€‚
	- ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—æ™‚ã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¾—ãŸã„ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚

### getAmountOut

ç‰¹å®šã®é‡ã®å…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆ`amountIn`ï¼‰ã‚’ãƒˆãƒ¼ã‚¯ãƒ³äº¤æ›ã§ã‚¹ãƒ¯ãƒƒãƒ—ã—ãŸéš›ã«å—ã‘å–ã‚‹å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆ`amountOut`ï¼‰ã®é‡ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã€‚

**å¼•æ•°**

- `amountOut`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã®ç›®æ¨™ã®å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚
- `reserveIn`
	- ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢å†…ã®å…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒªã‚¶ãƒ¼ãƒ–ï¼ˆä¿æœ‰ï¼‰é‡ã€‚
	- ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—æ™‚ã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ¸¡ã™ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚
- `reserveOut`
	- ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢å†…ã®å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒªã‚¶ãƒ¼ãƒ–ï¼ˆä¿æœ‰ï¼‰é‡ã€‚
	- ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—æ™‚ã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¾—ãŸã„ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚

### getAmountsIn

æŒ‡å®šã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒ‘ã‚¹å†…ã§ç‰¹å®šã®å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ã‚’å¾—ã‚‹ãŸã‚ã«å¿…è¦ãªå…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã€‚
ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã†éš›ã«ç›®æ¨™ã®å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ã‚’é”æˆã™ã‚‹ãŸã‚ã«å¿…è¦ãªå…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ã‚’æŠŠæ¡ã—ãŸã„å ´åˆã«ã€ã“ã®é–¢æ•°ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

**å¼•æ•°**

- `amountOut`
	- å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã®ç›®æ¨™é‡ã€‚
	- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¾—ãŸã„å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ã€‚
- `path`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒ‘ã‚¹ã€‚
	- ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã†éš›ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¹ãƒ¯ãƒƒãƒ—é †åºã‚’ç¤ºã™ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é…åˆ—ã€‚

ä¾‹ãˆã°ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä»¥ä¸‹ã®ã‚ˆã†ãªãƒˆãƒ¼ã‚¯ãƒ³ãƒ‘ã‚¹ã‚’æŒã¤ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã„ãŸã„ã¨ã—ã¾ã™ã€‚

ãƒˆãƒ¼ã‚¯ãƒ³ãƒ‘ã‚¹: `[TokenA, TokenB, TokenC]`
å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡: `100 TokenC`

ã“ã®ä¾‹ã§ã¯ã€ã€Œ**TokenA**ã€ã‹ã‚‰å§‹ã¾ã‚Šã€ã€Œ**TokenB**ã€ã‚’çµŒç”±ã—ã¦æœ€çµ‚çš„ã«ã€Œ**TokenC**ã€ã‚’å¾—ã‚‹ãŸã‚ã®ãƒˆãƒ¼ã‚¯ãƒ³ãƒ‘ã‚¹ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã™ã€‚

æˆ»ã‚Šå€¤ã§ã‚ã‚‹ã€Œ`amounts`ã€é…åˆ—ã«ã¯ã€å„ãƒˆãƒ¼ã‚¯ãƒ³ãŒå¿…è¦ã¨ã™ã‚‹å…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
ä¾‹ãˆã°ã€ã€Œamounts[0]ã€ã¯ã€ŒTokenAã€ã®å¿…è¦ãªå…¥åŠ›é‡ã€ã€Œamounts[1]ã€ã¯ã€ŒTokenBã€ã®å¿…è¦ãªå…¥åŠ›é‡ã‚’ç¤ºã—ã¾ã™ã€‚

### getAmountsOut

æŒ‡å®šã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒ‘ã‚¹å†…ã§ç‰¹å®šã®å…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ã§å¾—ã‚‰ã‚Œã‚‹å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã€‚

**å¼•æ•°**

- `amountIn`
	- å…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚
	- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ¸¡ã™ã“ã¨ãŒã§ãã‚‹ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚
- `path`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒ‘ã‚¹ã€‚
	- ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã†éš›ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¹ãƒ¯ãƒƒãƒ—é †åºã‚’ç¤ºã™ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é…åˆ—ã€‚

ä¾‹ãˆã°ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä»¥ä¸‹ã®ã‚ˆã†ãªãƒˆãƒ¼ã‚¯ãƒ³ãƒ‘ã‚¹ã‚’æŒã¤ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã„ãŸã„ã¨ã—ã¾ã™ã€‚

ãƒˆãƒ¼ã‚¯ãƒ³ãƒ‘ã‚¹å†…ã®å„ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã«å¯¾ã™ã‚‹æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ãŒæ ¼ç´ã•ã‚ŒãŸã€Œ`amounts`ã€é…åˆ—ã‚’è¿”ã—ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã†éš›ã®äºˆæ¸¬ãŒå¯èƒ½ã¨ãªã‚Šã¾ã™ã€‚

### quote

UniswapV2ãƒ—ãƒ¼ãƒ«å†…ã®ãƒˆãƒ¼ã‚¯ãƒ³Aã¨ãƒˆãƒ¼ã‚¯ãƒ³Bã®ç¾åœ¨ã®ãƒªã‚¶ãƒ¼ãƒ–ã«åŸºã¥ã„ã¦ã€ä¸Žãˆã‚‰ã‚ŒãŸé‡ã®ãƒˆãƒ¼ã‚¯ãƒ³Aã¨å¼•ãæ›ãˆã«å—ã‘å–ã‚‹ã“ã¨ãŒã§ãã‚‹ãƒˆãƒ¼ã‚¯ãƒ³Bã®é‡ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã€‚

**å¼•æ•°**

- `amountA`
	- äº¤æ›ã•ã‚Œã‚‹ãƒˆãƒ¼ã‚¯ãƒ³Aã®é‡ã€‚
- `reserveA`
	- UniswapV2ãƒ—ãƒ¼ãƒ«å†…ã®ãƒˆãƒ¼ã‚¯ãƒ³Aã®ç¾åœ¨ã®ãƒªã‚¶ãƒ¼ãƒ–ï¼ˆä¿æœ‰é‡ï¼‰ã€‚
- `reserveB`
	- UniswapV2ãƒ—ãƒ¼ãƒ«å†…ã®ãƒˆãƒ¼ã‚¯ãƒ³Bã®ç¾åœ¨ã®ãƒªã‚¶ãƒ¼ãƒ–ï¼ˆä¿æœ‰é‡ï¼‰ã€‚

æ¸¡ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³Aã®é‡ã«å¯¾ã—ã¦ã€ç¾åœ¨ã®ãƒˆãƒ¼ã‚¯ãƒ³Aã¨ãƒˆãƒ¼ã‚¯ãƒ³Bã®ãƒªã‚¶ãƒ¼ãƒ–ã‚’åŸºã«ã—ã¦ã€å—ã‘å–ã‚‹ã“ã¨ãŒã§ãã‚‹ãƒˆãƒ¼ã‚¯ãƒ³Bã®é‡ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
è¨ˆç®—çµæžœã§ã‚ã‚‹ã€ä¸Žãˆã‚‰ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³Aã®é‡ã«å¯¾ã—ã¦äº¤æ›ã§ãã‚‹ãƒˆãƒ¼ã‚¯ãƒ³Bã®é‡ã¯ã€Œ`amountB`ã€ã¨ã„ã†å€¤ã¨ã—ã¦è¿”ã•ã‚Œã¾ã™ã€‚


## WRITE

### addLiquidity

ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒåˆ†æ•£åž‹å–å¼•æ‰€ã®ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã«å¯¾ã—ã¦æµå‹•æ€§ã‚’è¿½åŠ ã™ã‚‹é–¢æ•°ã€‚

**å¼•æ•°**

- `tokenA`
	- ãƒšã‚¢å†…ã®æœ€åˆã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `tokenB`
	- ãƒšã‚¢å†…ã®2ç•ªç›®ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `amountADesired`
	- æµå‹•æ€§ã¨ã—ã¦è¿½åŠ ã™ã‚‹å¸Œæœ›ã®ãƒˆãƒ¼ã‚¯ãƒ³Aã®é‡ã€‚
- `amountBDesired`
	- æµå‹•æ€§ã¨ã—ã¦è¿½åŠ ã™ã‚‹å¸Œæœ›ã®ãƒˆãƒ¼ã‚¯ãƒ³Bã®é‡ã€‚
- `amountAMin`
	- å…¬æ­£ãªäº¤æ›ãƒ¬ãƒ¼ãƒˆã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã«æœ€å°é™è¿½åŠ ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ãƒˆãƒ¼ã‚¯ãƒ³Aã®é‡ã€‚
- `amountBMin`
	- å…¬æ­£ãªäº¤æ›ãƒ¬ãƒ¼ãƒˆã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã«æœ€å°é™è¿½åŠ ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ãƒˆãƒ¼ã‚¯ãƒ³Bã®é‡ã€‚
- `to`
	- æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ãŒç™ºè¡Œã•ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `deadline`
	- å–å¼•ãŒæœ‰åŠ¹ãªæœŸé™ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€‚

**æˆ»ã‚Šå€¤**

- `amountA`
	- å®Ÿéš›ã«æµå‹•æ€§ã¨ã—ã¦è¿½åŠ ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³Aã®é‡ã€‚
- `amountB`
	- å®Ÿéš›ã«æµå‹•æ€§ã¨ã—ã¦è¿½åŠ ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³Bã®é‡ã€‚
- `liquidity`
	- ç™ºè¡Œã•ã‚ŒãŸæµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ã€‚

å¸Œæœ›ã®ãƒˆãƒ¼ã‚¯ãƒ³Aã¨ãƒˆãƒ¼ã‚¯ãƒ³Bã®é‡ã‚’æŒ‡å®šã—ã¦æµå‹•æ€§ã‚’æä¾›ã—ã¾ã™ã€‚
ã¾ãŸã€å…¬æ­£ãªäº¤æ›ãƒ¬ãƒ¼ãƒˆã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã«æœ€å°é™è¿½åŠ ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ãƒˆãƒ¼ã‚¯ãƒ³Aã¨ãƒˆãƒ¼ã‚¯ãƒ³Bã®æœ€å°é‡ã‚‚æŒ‡å®šã—ã¾ã™ã€‚
æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã¯ç™ºè¡Œã•ã‚Œã¦æŒ‡å®šã•ã‚ŒãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã«é€ä¿¡ã•ã‚Œã¾ã™ã€‚
é‡è¦ãªç‚¹ã¨ã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸæœŸé™ã¾ã§ã«å–å¼•ã‚’å®Ÿè¡Œã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã§ã™ã€‚
æœŸé™ã‚’éŽãŽã‚‹ã¨å–å¼•ã¯ç„¡åŠ¹ã¨ã•ã‚Œã¾ã™ã€‚

1. `_addLiquidity`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³Aã¨ãƒˆãƒ¼ã‚¯ãƒ³Bã®æµå‹•æ€§ã‚’è¿½åŠ ã—ã¾ã™
2. ãƒšã‚¢ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨ˆç®—ã—ã¦å–å¾—ã—ã¾ã™ã€‚
3. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰æŒ‡å®šã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³Aã¨ãƒˆãƒ¼ã‚¯ãƒ³Bã‚’ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã«é€ä¿¡ã—ã¾ã™ã€‚
4. ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã«æµå‹•æ€§ã‚’è¿½åŠ ã—ã€è¿½åŠ ã•ã‚ŒãŸæµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã‚’å–å¾—ã—ã¾ã™ã€‚

:::message
`amountAMin`ã¨`amountBMin`ãŒæ´»ç”¨ã•ã‚Œã‚‹å ´é¢ã¨ã—ã¦ã¯ä»¥ä¸‹ãŒæŒ™ã’ã‚‰ã‚Œã¾ã™ã€‚
**ä¾¡æ ¼å¤‰å‹•ã«ã‚ˆã‚‹ã‚¹ãƒªãƒƒãƒšãƒ¼ã‚¸ã®é˜²æ­¢**
ãƒˆãƒ¼ã‚¯ãƒ³ã®ä¾¡æ ¼ã¯å¤‰å‹•ã™ã‚‹ãŸã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæŒ‡å®šã—ãŸé‡ã®ãƒˆãƒ¼ã‚¯ãƒ³Aã‚’æä¾›ã—ã¦ã‚‚ã€å®Ÿéš›ã«å—ã‘å–ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³Bã®é‡ãŒæœŸå¾…ã¨ç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚
ä¾‹ãˆã°ã€ãƒˆãƒ¼ã‚¯ãƒ³Aã®ä¾¡æ ¼ãŒæ€¥æ¿€ã«å¤‰å‹•ã—ãŸå ´åˆã€å–å¼•ãŒäºˆæƒ³ã‚ˆã‚Šã‚‚ä¸åˆ©ãªæ¡ä»¶ã§è¡Œã‚ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
ã“ã†ã—ãŸã‚¹ãƒªãƒƒãƒšãƒ¼ã‚¸ã‚’é˜²ããŸã‚ã«ã€ã€Œ`amountAMin`ã€ã‚’è¨­å®šã—ã€ä¸€å®šã®ãƒ¬ãƒ™ãƒ«ã®ä¿è­·ã‚’ç¢ºä¿ã§ãã¾ã™ã€‚

**å–å¼•ã®ä¿¡é ¼æ€§ç¢ºä¿**
ã€Œ`amountAMin`ã€ã‚’é©åˆ‡ã«è¨­å®šã™ã‚‹ã“ã¨ã§ã€ä»–ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚„ä¾¡æ ¼ã®å¤‰å‹•ã«ã‚ˆã£ã¦ã‚‚ãŸã‚‰ã•ã‚Œã‚‹ä¸åˆ©ãªçŠ¶æ³ã«å¯¾å‡¦ã§ãã¾ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯æœ€å°é™ã®å–å¼•æ¡ä»¶ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§ã€æ„å›³ã—ãŸé€šã‚Šã®äº¤æ›ãƒ¬ãƒ¼ãƒˆã§å–å¼•ãŒè¡Œã‚ã‚Œã‚‹ã“ã¨ã‚’ç¢ºå®Ÿã«ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

**æ”»æ’ƒã‹ã‚‰ã®ä¿è­·**
æ‚ªæ„ã‚ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚„æ”»æ’ƒè€…ãŒæ„å›³çš„ã«å–å¼•ä¾¡æ ¼ã‚’æ­ªã‚ã‚ˆã†ã¨ã™ã‚‹å ´åˆã€æœ€å°é™ã®å–å¼•æ¡ä»¶ã‚’è¨­å®šã™ã‚‹ã“ã¨ã§ã€ãã®å½±éŸ¿ã‚’è»½æ¸›ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
:::

### addLiquidityETH

ãƒˆãƒ¼ã‚¯ãƒ³ã¨æœ€å°é™ã®ETHã‚’æä¾›ã—ã¦ã€ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã«æµå‹•æ€§ã‚’è¿½åŠ ã™ã‚‹é–¢æ•°ã€‚

**å¼•æ•°**

- `token`
	- æµå‹•æ€§ã‚’è¿½åŠ ã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `amountTokenDesired`
	- æµå‹•æ€§ã¨ã—ã¦è¿½åŠ ã™ã‚‹å¸Œæœ›ã®ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚
- `amountTokenMin`
	- æœ€å°é™ã«è¿½åŠ ã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã€‚
- `amountETHMin`
	- æœ€å°é™ã«è¿½åŠ ã™ã‚‹ETHã®æ•°é‡ã€‚
- `to`
	- æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å—ã‘å–ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹
- `deadline`
	- å–å¼•ãŒæœ‰åŠ¹ãªæœŸé™ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€‚

**æˆ»ã‚Šå€¤**

- `amountToken`
	- å®Ÿéš›ã«è¿½åŠ ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã€‚
- `amountETH`
	- å®Ÿéš›ã«è¿½åŠ ã•ã‚ŒãŸETHã®æ•°é‡ã€‚
- `liquidity`
	- ç™ºè¡Œã•ã‚ŒãŸæµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ã€‚

å¸Œæœ›ã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã¨æœ€å°é™ã®ETHã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã€ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã«æµå‹•æ€§ã‚’è¿½åŠ ã§ãã¾ã™ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæä¾›ã—ãŸå¸Œæœ›æ•°é‡ã¨æœ€å°æ•°é‡ã«åŸºã¥ã„ã¦ã€æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã®ç¾åœ¨ã®ãƒªã‚¶ãƒ¼ãƒ–ï¼ˆä¿æœ‰é‡ï¼‰ã«åŸºã¥ã„ã¦å®Ÿéš›ã®ãƒˆãƒ¼ã‚¯ãƒ³ã¨ETHã®æ•°é‡ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
å¯¾å¿œã™ã‚‹é‡ã®æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæŒ‡å®šã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã«Mintã—ã¾ã™ã€‚

1. `_addLiquidity`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã¨ETHã‚’æµå‹•æ€§ã«è¿½åŠ ã—ã¾ã™ã€‚
2. ãƒšã‚¢ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨ˆç®—ã—ã¦å–å¾—ã—ã¾ã™ã€‚
3. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰æŒ‡å®šã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã«é€ä¿¡ã—ã¾ã™ã€‚
4. ETHã‚’WETHã«å¤‰æ›ã—ã¦ã€ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã«é€ä¿¡ã—ã¾ã™ã€‚
5. ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã«æµå‹•æ€§ã‚’è¿½åŠ ã—ã€è¿½åŠ ã•ã‚ŒãŸæµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã‚’å–å¾—ã—ã¾ã™ã€‚
6. ã‚‚ã—ä½™åˆ†ãªETHãŒã‚ã‚‹å ´åˆã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è¿”é‡‘ã—ã¾ã™ã€‚

### removeLiquidity

ãƒªã‚¶ãƒ¼ãƒ–ãƒ—ãƒ¼ãƒ«ã‹ã‚‰æµå‹•æ€§ã‚’å–ã‚Šå‡ºã™é–¢æ•°ã€‚

**å¼•æ•°**

- `tokenA`
	- ãƒ—ãƒ¼ãƒ«å†…ã®ç‰‡æ–¹ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `tokenB`
	- ãƒ—ãƒ¼ãƒ«å†…ã®ã‚‚ã†ç‰‡æ–¹ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `liquidity`
	- å–ã‚Šå‡ºã™æµå‹•æ€§ã®é‡ã€‚
- `amountAMin`
	- å—ã‘å–ã‚ŠãŸã„æœ€å°ã®ãƒˆãƒ¼ã‚¯ãƒ³Aã®é‡ã€‚
- `amountBMin`
	- å—ã‘å–ã‚ŠãŸã„æœ€å°ã®ãƒˆãƒ¼ã‚¯ãƒ³Bã®é‡ã€‚
- `to`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã®é€ä»˜å…ˆã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `deadline`
	- å–å¼•ãŒæœ‰åŠ¹ãªæœŸé™ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€‚

1. å®Ÿè¡ŒæœŸé™ãŒéŽãŽã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€ã‚‚ã—æœŸé™ãŒéŽãŽã¦ã„ã‚‹å ´åˆã¯ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å·»ãæˆ»ã—ã¾ã™ã€‚
2. ãƒšã‚¢ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨ˆç®—ã—ã¦å–å¾—ã—ã¾ã™ã€‚
3. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰æŒ‡å®šã•ã‚ŒãŸæµå‹•æ€§ã‚’ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã«é€ä¿¡ã—ã¾ã™ã€‚
4. ãƒˆãƒ¼ã‚¯ãƒ³ãƒšã‚¢ã‹ã‚‰ãƒˆãƒ¼ã‚¯ãƒ³Aã¨ãƒˆãƒ¼ã‚¯ãƒ³Bã‚’å–ã‚Šå‡ºã—ã€ãã®æ•°é‡ã‚’å–å¾—ã—ã¾ã™ã€‚
5. ãƒˆãƒ¼ã‚¯ãƒ³Aã¨ãƒˆãƒ¼ã‚¯ãƒ³Bã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ã‚½ãƒ¼ãƒˆã—ã¦å–å¾—ã—ã¾ã™ã€‚
6. æ­£ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã‚’è¨­å®šã—ã¾ã™ã€‚
7. å–ã‚Šå‡ºã™ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ãŒãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæŒ‡å®šã—ãŸæœ€ä½Žé™ã®æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚
ã‚‚ã—æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ãªã„å ´åˆã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã¯å¤±æ•—ã—ã¾ã™ã€‚
8. æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã‚‹å ´åˆã€å–ã‚Šå‡ºã—ãŸãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã¨ã¨ã‚‚ã«å‡¦ç†ãŒçµ‚äº†ã—ã¾ã™ã€‚

### removeLiquidityETH

ETHã¨ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æŒ‡å®šã—ã¦æµå‹•æ€§ã‚’å–ã‚Šé™¤ãé–¢æ•°ã€‚

**å¼•æ•°**

- `token`
	- æµå‹•æ€§ã‚’å‰Šé™¤ã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `liquidity`
	- å‰Šé™¤ã™ã‚‹æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã€‚
- `amountTokenMin`
	- å—ã‘å–ã‚ŠãŸã„æœ€å°é™ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã€‚
- `amountETHMin`
	- å—ã‘å–ã‚ŠãŸã„æœ€å°é™ã®ETHã®æ•°é‡ã€‚
- `to`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã¨ETHã‚’å—ã‘å–ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `deadline`
	- å–å¼•ãŒæœ‰åŠ¹ãªæœŸé™ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€‚

1. å‰Šé™¤ã•ã‚ŒãŸæµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã‹ã‚‰å—ã‘å–ã‚‹äºˆå®šã®ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã¨ETHã®æ•°é‡ã‚’å–å¾—ã—ã¾ã™ã€‚
2. å—ã‘å–ã‚ŠãŸã„æœ€å°é™ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã¨ETHã®æ•°é‡ã‚’ç¢ºèªã—ã¾ã™ã€‚
ã‚‚ã—æ¡ä»¶ã‚’æº€ãŸã•ãªã„å ´åˆã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã¯å¤±æ•—ã—ã¾ã™ã€‚
3. å‰Šé™¤ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã‚’æŒ‡å®šã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆ`to`ï¼‰ã«é€ä¿¡ã—ã¾ã™ã€‚
4. å‰Šé™¤ã•ã‚ŒãŸWETHã‚’ETHã«å¤‰æ›ã—ã¦å–å¾—ã—ã¾ã™ã€‚
5. å–å¾—ã—ãŸETHã‚’æŒ‡å®šã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆ`to`ï¼‰ã«é€ä¿¡ã—ã¾ã™ã€‚

### removeLiquidityETHWithPermit

ERC20ãƒˆãƒ¼ã‚¯ãƒ³ã¨ETHã®æµå‹•æ€§ã‚’å‰Šé™¤ã™ã‚‹æ“ä½œã‚’ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«è¨±å¯ã—ã¦å®Ÿè¡Œã™ã‚‹é–¢æ•°ã€‚
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯åˆ¥ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«æ“ä½œè¨±å¯ã‚’ä¸Žãˆã¤ã¤æŒ‡å®šã—ãŸãƒˆãƒ¼ã‚¯ãƒ³ã¨ETHã‚’ä½¿ã£ã¦æµå‹•æ€§ã‚’å‰Šé™¤ã—ã€å—ã‘å–ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã¨ETHã®æ•°é‡ã‚’åˆ¶å¾¡ã§ãã¾ã™ã€‚

**å¼•æ•°**

- `token`
	- æµå‹•æ€§ã‚’å‰Šé™¤ã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `liquidity`
	- å‰Šé™¤ã™ã‚‹æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã€‚
- `amountTokenMin`
	- å—ã‘å–ã‚ŠãŸã„æœ€å°é™ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã€‚
- `amountETHMin`
	- å—ã‘å–ã‚ŠãŸã„æœ€å°é™ã®ETHã®æ•°é‡ã€‚
- `to`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã¨ETHã‚’å—ã‘å–ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `deadline`
	- å–å¼•ãŒæœ‰åŠ¹ãªæœŸé™ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€‚
- `approveMax`
	- æœ€å¤§å€¤ã‚’æ‰¿èªã™ã‚‹ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°ã€‚
- `v`, `r`, `s`
	- è¨±å¯ã‚’ä¸Žãˆã‚‹ãŸã‚ã®ç½²åé–¢é€£ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€‚

1. æŒ‡å®šã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã¨WETHã®ãƒšã‚¢ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¾ã™ã€‚
2. `approveMax`ãŒ`true`ã®å ´åˆã€ä»–ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«`transfer`è¨±å¯ã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã‚’æœ€å¤§å€¤ï¼ˆç„¡é™å¤§ï¼‰ã«è¨­å®šã—ã¾ã™ã€‚
ãã†ã§ãªã„å ´åˆã€æŒ‡å®šã•ã‚ŒãŸæµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã‚’è¨­å®šã—ã¾ã™ã€‚
3. `IUniswapV2Pairã®permit`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€ç½²åæ¤œè¨¼å¾Œã‚¹ãƒžãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ“ä½œã™ã‚‹è¨±å¯ã‚’ä¸Žãˆã¾ã™ã€‚
4. `removeLiquidityETH`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã¨ETHã®æµå‹•æ€§ã‚’å‰Šé™¤ã—ã¾ã™ã€‚
5. å‰Šé™¤ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã¨ETHã®æ•°é‡ã‚’å–å¾—ã—ã¾ã™ã€‚

### removeLiquidityWithPermit

ERC20ãƒˆãƒ¼ã‚¯ãƒ³ã®æµå‹•æ€§ã‚’å‰Šé™¤ã™ã‚‹æ“ä½œã‚’ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«è¨±å¯ã—ã¦å®Ÿè¡Œã™ã‚‹é–¢æ•°ã€‚

**å¼•æ•°**

- `tokenA`
	- æµå‹•æ€§ã‚’å‰Šé™¤ã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³Aã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `tokenB`
	- æµå‹•æ€§ã‚’å‰Šé™¤ã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³Bã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `liquidity`
	- å‰Šé™¤ã™ã‚‹æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã€‚
- `amountAMin`
	- å—ã‘å–ã‚ŠãŸã„æœ€å°é™ã®ãƒˆãƒ¼ã‚¯ãƒ³Aã®æ•°é‡ã€‚
- `amountBMin`
	- å—ã‘å–ã‚ŠãŸã„æœ€å°é™ã®ãƒˆãƒ¼ã‚¯ãƒ³Bã®æ•°é‡ã€‚
- `to`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å—ã‘å–ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `deadline`
	- å–å¼•ãŒæœ‰åŠ¹ãªæœŸé™ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€‚
- `approveMax`
	- æœ€å¤§å€¤ã‚’æ‰¿èªã™ã‚‹ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°ã€‚
- `v`, `r`, `s`
	- è¨±å¯ã‚’ä¸Žãˆã‚‹ãŸã‚ã®ç½²åé–¢é€£ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€‚

1. `pair`ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã€æŒ‡å®šã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³Aã¨ãƒˆãƒ¼ã‚¯ãƒ³Bã®ãƒšã‚¢ã‚’ç‰¹å®šã—ã¾ã™ã€‚
2. `approveMax`ã®å€¤ã«åŸºã¥ã„ã¦ã€ãƒˆãƒ¼ã‚¯ãƒ³ã®æ•°é‡ã‚’è¨±å¯ã™ã‚‹ã‹ã©ã†ã‹ã‚’æ±ºå®šã—ã€ãã‚Œã«å¿œã˜ã¦ `value`å¤‰æ•°ã‚’è¨­å®šã—ã¾ã™ã€‚
3. **IUniswapV2Pair(pair)** ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¨±å¯ã‚’ç‰¹å®šã®ãƒˆãƒ¼ã‚¯ãƒ³ã«ä¸Žãˆã‚‹`permit`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ãƒˆãƒ¼ã‚¯ãƒ³ã®æµå‹•æ€§ã‚’å‰Šé™¤ã™ã‚‹æ“ä½œã‚’ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«è¨±å¯ã—ã¾ã™ã€‚
4. `removeLiquidity`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€å®Ÿéš›ã«æµå‹•æ€§ã‚’å‰Šé™¤ã—ã¾ã™ã€‚
5. ã“ã‚Œã«ã‚ˆã‚Šã€ãƒˆãƒ¼ã‚¯ãƒ³Aã¨ãƒˆãƒ¼ã‚¯ãƒ³Bã‚’å–å¾—ã—ã¦ãƒˆãƒ¼ã‚¯ãƒ³Aã¨ãƒˆãƒ¼ã‚¯ãƒ³Bã®æ•°é‡ã‚’è¿”ã—ã¾ã™ã€‚

### swapETHForExactTokens

ç‰¹å®šã®é‡ã®ETHã‚’ä¸€å®šã®é‡ã®ãƒˆãƒ¼ã‚¯ãƒ³ã«äº¤æ›ã™ã‚‹ãŸã‚ã®é–¢æ•°ã€‚

**å¼•æ•°**

- `amountOut`
	- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¹ãƒ¯ãƒƒãƒ—ã§å—ã‘å–ã‚ŠãŸã„ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚
- `path`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã®ãƒ‘ã‚¹ã‚’ç¤ºã™ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é…åˆ—ã€‚
	- é…åˆ—ã®æœ€åˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯å—ã‘å–ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚ã‚Šã€æœ€å¾Œã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯æä¾›ã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã€‚
- `to`
	- äº¤æ›ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ãŒé€ä¿¡ã•ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `deadline`
	- å–å¼•ãŒæœ‰åŠ¹ãªæœŸé™ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€‚

ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã‚’å‡¦ç†ã™ã‚‹å¤–éƒ¨ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚„ã‚µãƒ¼ãƒ“ã‚¹ã‚’å‘¼ã³å‡ºã—ã¦ã‚¹ãƒ¯ãƒƒãƒ—ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

### swapExactETHForTokens

ç‰¹å®šã®é‡ã®ETHã‚’ä½¿ç”¨ã—ã¦ã€æœ€å°é™ã®ãƒˆãƒ¼ã‚¯ãƒ³é‡ã«ã‚¹ãƒ¯ãƒƒãƒ—ã™ã‚‹é–¢æ•°ã€‚

**å¼•æ•°**

- `amountOutMin`
	- ã‚¹ãƒ¯ãƒƒãƒ—ã§å—ã‘å–ã‚‹ã¨äºˆæƒ³ã—ã¦ã„ã‚‹æœ€å°ã®ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚
- `path`
	- ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã®ãƒ‘ã‚¹ã‚’ç¤ºã™ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é…åˆ—ã€‚
	- é…åˆ—ã®æœ€åˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯å—ã‘å–ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚ã‚Šã€æœ€å¾Œã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ETHã¨äº¤æ›ã™ã‚‹ãŸã‚ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `to`
	- äº¤æ›ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ãŒé€ä¿¡ã•ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `deadline`
	- å–å¼•ãŒæœ‰åŠ¹ãªæœŸé™ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€‚

:::message
`amountOutMin`ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæœ€ä½Žé™å—ã‘å–ã‚ŠãŸã„ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ã‚’æŒ‡å®šã—ã¾ã™ã€‚
:::

### swapExactTokensForETH

ç‰¹å®šã®é‡ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ETHã«ã‚¹ãƒ¯ãƒƒãƒ—ã™ã‚‹ãŸã‚ã®é–¢æ•°ã€‚
ç‰¹å®šã®é‡ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å—ã‘å–ã‚Šã€æœ€å°é™ã®ETHã‚’æœŸå¾…é€šã‚Šã«å—ã‘å–ã‚‹ãŸã‚ã®æ‰‹é †ã‚’æä¾›ã—ã¾ã™ã€‚

**å¼•æ•°**

- `amountIn`
	- äº¤æ›ã—ãŸã„ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚
- `amountOutMin`
        - ã‚¹ãƒ¯ãƒƒãƒ—ã§å—ã‘å–ã‚‹ã¨äºˆæƒ³ã—ã¦ã„ã‚‹æœ€å°ã®ETHé‡ã€‚
- `path`
        - ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã®ãƒ‘ã‚¹ã‚’ç¤ºã™ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é…åˆ—ã€‚
        - é…åˆ—ã®æœ€åˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯å—ã‘å–ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚ã‚Šã€æœ€å¾Œã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ETHã¨äº¤æ›ã™ã‚‹ãŸã‚ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `to`
        - äº¤æ›ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ãŒé€ä¿¡ã•ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `deadline`
        - å–å¼•ãŒæœ‰åŠ¹ãªæœŸé™ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€‚

1. ãƒ‘ã‚¹ã®æœ€å¾Œã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒWETHï¼ˆETHã®ãƒ©ãƒƒãƒ—ãƒˆãƒ¼ã‚¯ãƒ³ï¼‰ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚
2. ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã®ãŸã‚ã®ãƒˆãƒ¼ã‚¯ãƒ³ãƒ‘ã‚¹ã«åŸºã¥ã„ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæŒ‡å®šã—ãŸãƒˆãƒ¼ã‚¯ãƒ³é‡ã‹ã‚‰è¨ˆç®—ã•ã‚ŒãŸETHã®äºˆæƒ³åŽç›Šã‚’ç®—å‡ºã—ã¾ã™ã€‚
3. `amountOutMin`ã§æŒ‡å®šã—ãŸæœ€å°ã®ETHåŽç›Šã‚’ç¢ºèªã—ã€ãã®åŽç›Šã‚’æœŸå¾…é€šã‚Šã«å—ã‘å–ã‚‹ãŸã‚ã®ãƒˆãƒ¼ã‚¯ãƒ³é‡ãŒååˆ†ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚
4. `path[0]`ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰å—ã‘å–ã‚Šã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ã‚¹ãƒ¯ãƒƒãƒ—ã™ã‚‹ãŸã‚ã®ãƒšã‚¢ã«é€ä¿¡ã—ã¾ã™ã€‚
5. `_swap`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
6. `to`ã§æŒ‡å®šã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã¸ãƒˆãƒ¼ã‚¯ãƒ³ã‚’é€ã‚‹ã€‚
7. **4**~**6**ã®æ“ä½œã‚’`path`é…åˆ—åˆ†å®Ÿè¡Œã™ã‚‹ã€‚
9. **WETH**ã‚’ãƒˆãƒ¼ã‚¯ãƒ³ã«æˆ»ã™ãŸã‚ã«ã€**WETH**ã‚’`withdraw`ã—ã€ãã®ETHã‚’æŒ‡å®šã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ `to`ã«é€ä¿¡ã—ã¾ã™ã€‚

### swapExactTokensForTokens

ç‰¹å®šã®é‡ã®å…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æœŸå¾…ã™ã‚‹æœ€å°ã®å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ã«äº¤æ›ã™ã‚‹é–¢æ•°ã€‚
ç‰¹å®šã®é‡ã®å…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æœ€å°ã®å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³åŽç›Šã«äº¤æ›ã™ã‚‹ãŸã‚ã®æ‰‹é †ã‚’æä¾›ã—ã¾ã™ã€‚

**å¼•æ•°**

- `amountIn`
	- äº¤æ›ã—ãŸã„ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚
- `amountOutMin`
        - ã‚¹ãƒ¯ãƒƒãƒ—ã§å—ã‘å–ã‚‹ã¨äºˆæƒ³ã—ã¦ã„ã‚‹æœ€å°ã®ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚
- `path`
        - ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã®ãƒ‘ã‚¹ã‚’ç¤ºã™ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é…åˆ—ã€‚
        - é…åˆ—ã®æœ€åˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯å—ã‘å–ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚ã‚Šã€æœ€å¾Œã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ãƒˆãƒ¼ã‚¯ãƒ³ã¨äº¤æ›ã™ã‚‹ãŸã‚ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `to`
        - äº¤æ›ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ãŒé€ä¿¡ã•ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `deadline`
        - å–å¼•ãŒæœ‰åŠ¹ãªæœŸé™ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€‚

1. ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã®ãŸã‚ã®ãƒˆãƒ¼ã‚¯ãƒ³ãƒ‘ã‚¹ã«åŸºã¥ã„ã¦ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæŒ‡å®šã—ãŸå…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ã‹ã‚‰è¨ˆç®—ã•ã‚ŒãŸå‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³ã®äºˆæƒ³åŽç›Šã‚’ç®—å‡ºã—ã¾ã™ã€‚
2. `amountOutMin`ã§æŒ‡å®šã—ãŸæœ€å°ã®å‡ºåŠ›ãƒˆãƒ¼ã‚¯ãƒ³åŽç›Šã‚’ç¢ºèªã—ã€ãã®åŽç›Šã‚’æœŸå¾…é€šã‚Šã«å—ã‘å–ã‚‹ãŸã‚ã®ãƒˆãƒ¼ã‚¯ãƒ³é‡ãŒååˆ†ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚
3. `path[0]`ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰å—ã‘å–ã‚Šã€ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ã‚¹ãƒ¯ãƒƒãƒ—ã™ã‚‹ãŸã‚ã®ãƒšã‚¢ã«é€ä¿¡ã—ã¾ã™ã€‚
4. `_swap`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
5. `to`ã§æŒ‡å®šã—ãŸã‚¢ãƒ‰ãƒ¬ã‚¹ã¸ãƒˆãƒ¼ã‚¯ãƒ³ã‚’é€ã‚‹ã€‚
6. **3**~**5**ã®æ“ä½œã‚’`path`é…åˆ—åˆ†å®Ÿè¡Œã™ã‚‹ã€‚
### swapTokensForExactETH

å—ã‘å–ã‚ŠãŸã„ETHã®æ­£ç¢ºãªé‡ã‚’æŒ‡å®šã—ã¦ãƒˆãƒ¼ã‚¯ãƒ³ã¨ã‚¹ãƒ¯ãƒƒãƒ—ã™ã‚‹é–¢æ•°ã€‚
ã‚¹ãƒ¯ãƒƒãƒ—ã§å—ã‘å–ã‚‹ETHã®é‡ãŒæ­£ç¢ºã«æŒ‡å®šã•ã‚Œã¦ã„ã¦ã€æœ€å¤§ã®å…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ã‚’æŒ‡å®šã—ãã®ç¯„å›²å†…ã§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’äº¤æ›ã—ã¾ã™ã€‚

**å¼•æ•°**

- `amountOut`
	- ã‚¹ãƒ¯ãƒƒãƒ—ã§å—ã‘å–ã‚ŠãŸã„ETHã®é‡ã€‚
- `amountInMax`
        - ã‚¹ãƒ¯ãƒƒãƒ—ã™ã‚‹æœ€å¤§ã®ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚
- `path`
        - ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã®ãƒ‘ã‚¹ã‚’ç¤ºã™ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é…åˆ—ã€‚
        - é…åˆ—ã®æœ€åˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯å—ã‘å–ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚ã‚Šã€æœ€å¾Œã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ETHã¨äº¤æ›ã™ã‚‹ãŸã‚ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `to`
        - ã‚¹ãƒ¯ãƒƒãƒ—ã•ã‚ŒãŸETHãŒé€ä¿¡ã•ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `deadline`
        - å–å¼•ãŒæœ‰åŠ¹ãªæœŸé™ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€‚

:::message
`swapTokensForExactETH`ã¨`swapExactTokensForETH`ã®é•ã„ã¯ä»¥ä¸‹ã«ãªã‚Šã¾ã™ã€‚

**swapTokensForExactETH**

- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå—ã‘å–ã‚ŠãŸã„ETHã®æ­£ç¢ºãªé‡ã‚’æŒ‡å®šã—ã¦ã€ãã®é‡ã«åˆã‚ã›ã¦ãƒˆãƒ¼ã‚¯ãƒ³ã‚’äº¤æ›ã—ã¾ã™ã€‚
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¹ãƒ¯ãƒƒãƒ—ã§å—ã‘å–ã‚‹ETHã®é‡ãŒæ­£ç¢ºã«æŒ‡å®šã•ã‚Œã¾ã™ã€‚
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯æœ€å¤§ã®å…¥åŠ›ãƒˆãƒ¼ã‚¯ãƒ³é‡ã‚’æŒ‡å®šã—ã€ãã®ç¯„å›²å†…ã§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’äº¤æ›ã—ã¾ã™ã€‚
- ãƒ‘ã‚¹ã«ã¯ãƒˆãƒ¼ã‚¯ãƒ³ã‹ã‚‰ETHã¸ã®ãƒ‘ã‚¹ã‚’æŒ‡å®šã—ã¾ã™ã€‚

**swapExactTokensForETH**

- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒäº¤æ›ã™ã‚‹æ­£ç¢ºãªãƒˆãƒ¼ã‚¯ãƒ³é‡ã‚’æŒ‡å®šã—ã¦ã€ãã®ãƒˆãƒ¼ã‚¯ãƒ³é‡ã«å¯¾å¿œã™ã‚‹ETHã®æœ€å°å—ã‘å–ã‚Šé‡ã‚’æŒ‡å®šã—ã¾ã™ã€‚
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¹ãƒ¯ãƒƒãƒ—ã§å—ã‘å–ã‚‹ETHã®æœ€å°é‡ãŒæŒ‡å®šã•ã‚Œã¾ã™ã€‚
- å®Ÿéš›ã«å—ã‘å–ã‚‹ETHã®é‡ã¯æœ€å°å€¤ä»¥ä¸Šã«ãªã‚Šã¾ã™ã€‚
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯äº¤æ›ã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ã‚’æ­£ç¢ºã«æŒ‡å®šã—ã¾ã™ã€‚
- ãƒ‘ã‚¹ã«ã¯ãƒˆãƒ¼ã‚¯ãƒ³ã‹ã‚‰ETHã¸ã®ãƒ‘ã‚¹ã‚’æŒ‡å®šã—ã¾ã™ã€‚
:::

### swapTokensForExactTokens

æŒ‡å®šã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³é‡ã‚’å—ã‘å–ã‚‹ãŸã‚ã«ã€æœ€å¤§ã§ã©ã‚Œã ã‘ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã‚’æŒ‡å®šã—ã¦ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã‚’è¡Œã†é–¢æ•°ã€‚

**å¼•æ•°**

- `amountOut`
	- ã‚¹ãƒ¯ãƒƒãƒ—ã§å—ã‘å–ã‚ŠãŸã„ãƒˆãƒ¼ã‚¯ãƒ³ã®é‡ã€‚
- `amountInMax`
        - ã‚¹ãƒ¯ãƒƒãƒ—ã™ã‚‹æœ€å¤§ã®ãƒˆãƒ¼ã‚¯ãƒ³é‡ã€‚
- `path`
        - ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã®ãƒ‘ã‚¹ã‚’ç¤ºã™ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é…åˆ—ã€‚
        - é…åˆ—ã®æœ€åˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯å—ã‘å–ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã§ã‚ã‚Šã€æœ€å¾Œã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ãƒˆãƒ¼ã‚¯ãƒ³ã¨äº¤æ›ã™ã‚‹ãŸã‚ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `to`
        - ã‚¹ãƒ¯ãƒƒãƒ—ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ãŒé€ä¿¡ã•ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `deadline`
        - å–å¼•ãŒæœ‰åŠ¹ãªæœŸé™ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã€‚

1. `amounts`é…åˆ—ã‚’è¨ˆç®—
`UniswapV2Library.getAmountsIn`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã€æŒ‡å®šã•ã‚ŒãŸ`amountOut`ã¨`path`ã«åŸºã¥ã„ã¦ã€å¿…è¦ãªãƒˆãƒ¼ã‚¯ãƒ³é‡ã®é…åˆ—`amounts`ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
ã“ã®é…åˆ—ã«ã¯ã€å„ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã‚¹ãƒ†ãƒƒãƒ—ã”ã¨ã«å¿…è¦ãªãƒˆãƒ¼ã‚¯ãƒ³é‡ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
2. æœ€å¤§å…¥åŠ›åˆ¶é™ã®ç¢ºèª
`amounts[0]`ãŒ`amountInMax`ä»¥ä¸‹ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã€æŒ‡å®šã•ã‚ŒãŸæœ€å¤§å…¥åŠ›é‡ã‚’è¶…ãˆãªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚
3. ãƒˆãƒ¼ã‚¯ãƒ³é€ä¿¡
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰æœ€åˆã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’`path`ã®æœ€åˆã®ãƒˆãƒ¼ã‚¯ãƒ³ã¸é€ä¿¡ã—ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¹ãƒ¯ãƒƒãƒ—ã®æº–å‚™ãŒæ•´ã„ã¾ã™ã€‚
4. `_swap`é–¢æ•°ã®å‘¼ã³å‡ºã—
`_swap`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¦ã€å®Ÿéš›ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒ¯ãƒƒãƒ—ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€æŒ‡å®šã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³é‡ã‚’ã‚¹ãƒ¯ãƒƒãƒ—ã—ã¦ã€å—ã‘å–ã‚‹ã¹ãæ­£ç¢ºãªãƒˆãƒ¼ã‚¯ãƒ³é‡ãŒç¢ºä¿ã•ã‚Œã¾ã™ã€‚
5. ã‚¹ãƒ¯ãƒƒãƒ—ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã®å—ã‘å–ã‚Š
ã‚¹ãƒ¯ãƒƒãƒ—ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ãŒ`to`ã‚¢ãƒ‰ãƒ¬ã‚¹ã«é€ä¿¡ã•ã‚Œã¾ã™ã€‚
6. **3**~**5**ã®å‹•ä½œã‚’ç¹°ã‚Šè¿”ã™ã€‚

# ã‚¤ãƒ™ãƒ³ãƒˆ

ç‰¹ã«ãªã—

# ã‚³ãƒ¼ãƒ‰

## IUniswapV2Factory

:::details IUniswapV2Factory
```solidity
// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol

pragma solidity >=0.5.0;

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}
```
:::

## TransferHelper

:::details TransferHelper
```solidity
// File: @uniswap/lib/contracts/libraries/TransferHelper.sol

pragma solidity >=0.6.0;

// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false
library TransferHelper {
    function safeApprove(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');
    }

    function safeTransfer(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
    }

    function safeTransferFrom(address token, address from, address to, uint value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
    }

    function safeTransferETH(address to, uint value) internal {
        (bool success,) = to.call{value:value}(new bytes(0));
        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');
    }
}
```
:::

## IUniswapV2Pair
:::details IUniswapV2Pair
```solidity
// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol

pragma solidity >=0.5.0;

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}
```
:::

## SafeMath

:::details SafeMath
```solidity
// File: contracts/libraries/SafeMath.sol

pragma solidity =0.6.6;

// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)

library SafeMath {
    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x, 'ds-math-add-overflow');
    }

    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x - y) <= x, 'ds-math-sub-underflow');
    }

    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');
    }
}
```
:::

## UniswapV2Library

:::details UniswapV2Library
```solidity
// File: contracts/libraries/UniswapV2Library.sol

pragma solidity >=0.5.0;



library UniswapV2Library {
    using SafeMath for uint;

    // returns sorted token addresses, used to handle return values from pairs sorted in this order
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
    }

    // calculates the CREATE2 address for a pair without making any external calls
    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint(keccak256(abi.encodePacked(
                hex'ff',
                factory,
                keccak256(abi.encodePacked(token0, token1)),
                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
            ))));
    }

    // fetches and sorts the reserves for a pair
    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }

    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        amountB = amountA.mul(reserveB) / reserveA;
    }

    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn.mul(997);
        uint numerator = amountInWithFee.mul(reserveOut);
        uint denominator = reserveIn.mul(1000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }

    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = reserveIn.mul(amountOut).mul(1000);
        uint denominator = reserveOut.sub(amountOut).mul(997);
        amountIn = (numerator / denominator).add(1);
    }

    // performs chained getAmountOut calculations on any number of pairs
    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[0] = amountIn;
        for (uint i; i < path.length - 1; i++) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // performs chained getAmountIn calculations on any number of pairs
    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint i = path.length - 1; i > 0; i--) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}
```
:::

## IUniswapV2Router01

:::details IUniswapV2Router01
```solidity
// File: contracts/interfaces/IUniswapV2Router01.sol

pragma solidity >=0.6.2;

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}
```
:::

## IERC20

:::details IERC20
```solidity
// File: contracts/interfaces/IERC20.sol

pragma solidity >=0.5.0;

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
}
```
:::

## IWETH
:::details IWETH
```solidity
// File: contracts/interfaces/IWETH.sol

pragma solidity >=0.5.0;

interface IWETH {
    function deposit() external payable;
    function transfer(address to, uint value) external returns (bool);
    function withdraw(uint) external;
}
```
:::

## UniswapV2Router01
:::details UniswapV2Router01
```solidity
// File: contracts/UniswapV2Router01.sol

pragma solidity =0.6.6;

// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol

pragma solidity >=0.5.0;

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

// File: @uniswap/lib/contracts/libraries/TransferHelper.sol

pragma solidity >=0.6.0;

// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false
library TransferHelper {
    function safeApprove(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');
    }

    function safeTransfer(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
    }

    function safeTransferFrom(address token, address from, address to, uint value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
    }

    function safeTransferETH(address to, uint value) internal {
        (bool success,) = to.call{value:value}(new bytes(0));
        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');
    }
}

// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol

pragma solidity >=0.5.0;

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external pure returns (string memory);
    function symbol() external pure returns (string memory);
    function decimals() external pure returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);
    function PERMIT_TYPEHASH() external pure returns (bytes32);
    function nonces(address owner) external view returns (uint);

    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;

    event Mint(address indexed sender, uint amount0, uint amount1);
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint amount0In,
        uint amount1In,
        uint amount0Out,
        uint amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint);
    function factory() external view returns (address);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function price0CumulativeLast() external view returns (uint);
    function price1CumulativeLast() external view returns (uint);
    function kLast() external view returns (uint);

    function mint(address to) external returns (uint liquidity);
    function burn(address to) external returns (uint amount0, uint amount1);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;

    function initialize(address, address) external;
}

// File: contracts/libraries/SafeMath.sol

pragma solidity =0.6.6;

// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)

library SafeMath {
    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x, 'ds-math-add-overflow');
    }

    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x - y) <= x, 'ds-math-sub-underflow');
    }

    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');
    }
}

// File: contracts/libraries/UniswapV2Library.sol

pragma solidity >=0.5.0;



library UniswapV2Library {
    using SafeMath for uint;

    // returns sorted token addresses, used to handle return values from pairs sorted in this order
    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {
        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');
    }

    // calculates the CREATE2 address for a pair without making any external calls
    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint(keccak256(abi.encodePacked(
                hex'ff',
                factory,
                keccak256(abi.encodePacked(token0, token1)),
                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
            ))));
    }

    // fetches and sorts the reserves for a pair
    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }

    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {
        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');
        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        amountB = amountA.mul(reserveB) / reserveA;
    }

    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {
        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint amountInWithFee = amountIn.mul(997);
        uint numerator = amountInWithFee.mul(reserveOut);
        uint denominator = reserveIn.mul(1000).add(amountInWithFee);
        amountOut = numerator / denominator;
    }

    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');
        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');
        uint numerator = reserveIn.mul(amountOut).mul(1000);
        uint denominator = reserveOut.sub(amountOut).mul(997);
        amountIn = (numerator / denominator).add(1);
    }

    // performs chained getAmountOut calculations on any number of pairs
    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[0] = amountIn;
        for (uint i; i < path.length - 1; i++) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);
            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
        }
    }

    // performs chained getAmountIn calculations on any number of pairs
    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {
        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');
        amounts = new uint[](path.length);
        amounts[amounts.length - 1] = amountOut;
        for (uint i = path.length - 1; i > 0; i--) {
            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);
            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
        }
    }
}

// File: contracts/interfaces/IUniswapV2Router01.sol

pragma solidity >=0.6.2;

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

// File: contracts/interfaces/IERC20.sol

pragma solidity >=0.5.0;

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
}

// File: contracts/interfaces/IWETH.sol

pragma solidity >=0.5.0;

interface IWETH {
    function deposit() external payable;
    function transfer(address to, uint value) external returns (bool);
    function withdraw(uint) external;
}

// File: contracts/UniswapV2Router01.sol

pragma solidity =0.6.6;







contract UniswapV2Router01 is IUniswapV2Router01 {
    address public immutable override factory;
    address public immutable override WETH;

    modifier ensure(uint deadline) {
        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');
        _;
    }

    constructor(address _factory, address _WETH) public {
        factory = _factory;
        WETH = _WETH;
    }

    receive() external payable {
        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract
    }

    // **** ADD LIQUIDITY ****
    function _addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin
    ) private returns (uint amountA, uint amountB) {
        // create the pair if it doesn't exist yet
        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {
            IUniswapV2Factory(factory).createPair(tokenA, tokenB);
        }
        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);
        if (reserveA == 0 && reserveB == 0) {
            (amountA, amountB) = (amountADesired, amountBDesired);
        } else {
            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);
            if (amountBOptimal <= amountBDesired) {
                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
                (amountA, amountB) = (amountADesired, amountBOptimal);
            } else {
                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);
                assert(amountAOptimal <= amountADesired);
                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
                (amountA, amountB) = (amountAOptimal, amountBDesired);
            }
        }
    }
    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {
        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);
        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);
        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);
        liquidity = IUniswapV2Pair(pair).mint(to);
    }
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {
        (amountToken, amountETH) = _addLiquidity(
            token,
            WETH,
            amountTokenDesired,
            msg.value,
            amountTokenMin,
            amountETHMin
        );
        address pair = UniswapV2Library.pairFor(factory, token, WETH);
        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);
        IWETH(WETH).deposit{value: amountETH}();
        assert(IWETH(WETH).transfer(pair, amountETH));
        liquidity = IUniswapV2Pair(pair).mint(to);
        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH); // refund dust eth, if any
    }

    // **** REMOVE LIQUIDITY ****
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) public override ensure(deadline) returns (uint amountA, uint amountB) {
        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair
        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);
        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);
        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');
        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');
    }
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) public override ensure(deadline) returns (uint amountToken, uint amountETH) {
        (amountToken, amountETH) = removeLiquidity(
            token,
            WETH,
            liquidity,
            amountTokenMin,
            amountETHMin,
            address(this),
            deadline
        );
        TransferHelper.safeTransfer(token, to, amountToken);
        IWETH(WETH).withdraw(amountETH);
        TransferHelper.safeTransferETH(to, amountETH);
    }
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external override returns (uint amountA, uint amountB) {
        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
        uint value = approveMax ? uint(-1) : liquidity;
        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);
    }
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external override returns (uint amountToken, uint amountETH) {
        address pair = UniswapV2Library.pairFor(factory, token, WETH);
        uint value = approveMax ? uint(-1) : liquidity;
        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);
    }

    // **** SWAP ****
    // requires the initial amount to have already been sent to the first pair
    function _swap(uint[] memory amounts, address[] memory path, address _to) private {
        for (uint i; i < path.length - 1; i++) {
            (address input, address output) = (path[i], path[i + 1]);
            (address token0,) = UniswapV2Library.sortTokens(input, output);
            uint amountOut = amounts[i + 1];
            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));
            address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(amount0Out, amount1Out, to, new bytes(0));
        }
    }
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external override ensure(deadline) returns (uint[] memory amounts) {
        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);
        _swap(amounts, path, to);
    }
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external override ensure(deadline) returns (uint[] memory amounts) {
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);
        _swap(amounts, path, to);
    }
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        override
        payable
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        IWETH(WETH).deposit{value: amounts[0]}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));
        _swap(amounts, path, to);
    }
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        override
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);
        _swap(amounts, path, address(this));
        IWETH(WETH).withdraw(amounts[amounts.length - 1]);
        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
    }
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        override
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        TransferHelper.safeTransferFrom(path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]);
        _swap(amounts, path, address(this));
        IWETH(WETH).withdraw(amounts[amounts.length - 1]);
        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
    }
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        override
        payable
        ensure(deadline)
        returns (uint[] memory amounts)
    {
        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');
        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
        require(amounts[0] <= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');
        IWETH(WETH).deposit{value: amounts[0]}();
        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));
        _swap(amounts, path, to);
        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]); // refund dust eth, if any
    }

    function quote(uint amountA, uint reserveA, uint reserveB) public pure override returns (uint amountB) {
        return UniswapV2Library.quote(amountA, reserveA, reserveB);
    }

    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) public pure override returns (uint amountOut) {
        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);
    }

    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure override returns (uint amountIn) {
        return UniswapV2Library.getAmountOut(amountOut, reserveIn, reserveOut);
    }

    function getAmountsOut(uint amountIn, address[] memory path) public view override returns (uint[] memory amounts) {
        return UniswapV2Library.getAmountsOut(factory, amountIn, path);
    }

    function getAmountsIn(uint amountOut, address[] memory path) public view override returns (uint[] memory amounts) {
        return UniswapV2Library.getAmountsIn(factory, amountOut, path);
    }
}
```
:::

# æœ€å¾Œã«

ä»Šå›žã®è¨˜äº‹ã§ã¯ã€Bunzzã®æ–°æ©Ÿèƒ½ã€ŽDeCipherã€ã‚’ä½¿ç”¨ã—ã¦ã€UniswapV2ã®ã€Œ**UniswapV2Router01**ã€ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’è¦‹ã¦ãã¾ã—ãŸã€‚
ã„ã‹ãŒã ã£ãŸã§ã—ã‚‡ã†ã‹ï¼Ÿ
ä»Šå¾Œã‚‚ç‰¹å®šã®NFTã‚„ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ãƒ”ãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã¦ã¾ã¨ã‚ã¦è¡ŒããŸã„ã¨æ€ã„ã¾ã™ã€‚

æ™®æ®µã¯ãƒ–ãƒ­ã‚°ã‚„Qiitaã§ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚„AIã«é–¢ã™ã‚‹è¨˜äº‹ã‚’æŒ™ã’ã¦ã„ã‚‹ã®ã§ã€ã‚ˆã‘ã‚Œã°è¦‹ã¦ã„ã£ã¦ãã ã•ã„ï¼

https://chaldene.net/

https://qiita.com/cardene
