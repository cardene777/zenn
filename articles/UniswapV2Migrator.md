---
title: "[Bunzz Decipher] UniswapV2Migratorã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ç†è§£ã—ã‚ˆã†ï¼"
emoji: "ğŸ¦„"
type: "tech"
topics:
  - "blockchain"
  - "ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³"
  - "solidity"
  - "ethereum"
  - "defi"
published: true
published_at: "2023-08-14 07:03"
publication_name: "cryptogames"
---

# ã¯ã˜ã‚ã«

åˆã‚ã¾ã—ã¦ã€‚
**CryptoGames**ã¨ã„ã†ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚²ãƒ¼ãƒ ä¼æ¥­ã§ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã‚’ã—ã¦ã„ã‚‹ **cardeneï¼ˆã‹ã‚‹ã§ã­ï¼‰** ã§ã™ï¼
ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’æ›¸ã„ãŸã‚Šã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ»ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ»ã‚¤ãƒ³ãƒ•ãƒ©ã¨å¹…åºƒãè§¦ã‚Œã¦ã„ã¾ã™ã€‚

https://cryptogames.co.jp/

ä»£è¡¨çš„ãªã‚²ãƒ¼ãƒ ã¯**ã‚¯ãƒªãƒ—ãƒˆã‚¹ãƒšãƒ«ã‚º**ã¨ã„ã†ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚²ãƒ¼ãƒ ã§ã™ã€‚

https://cryptospells.jp/

ä»Šå›ã¯Bunzzã®æ–°æ©Ÿèƒ½ã€**DeCipher**ã€ã‚’ä½¿ç”¨ã—ã¦ã€UniswapV2ã®ã€Œ**UniswapV2Pair**ã€ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’è¦‹ã¦ã¿ã‚ˆã†ã¨æ€ã„ã¾ã™ã€‚

ã€**DeCipher**ã€ã¯AIã‚’ä½¿ç”¨ã—ã¦ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’è‡ªå‹•ç”Ÿæˆã—ã¦ãã‚Œã‚‹ã‚µãƒ¼ãƒ“ã‚¹ã§ã™ã€‚

https://www.bunzz.dev/decipher

è©³ã—ã„ä½¿ã„æ–¹ã«é–¢ã—ã¦ã¯ä»¥ä¸‹ã®è¨˜äº‹ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ï¼

https://zenn.dev/heku/articles/33266f0c19d523

:::message
ã“ã®è¨˜äº‹ã¯ã‚ãã¾ã§å€‹äººãŒã€Œ**DeCipher**ã€ã‚’ä½¿ç”¨ã—ã¦ã¿ã¦ã®è¨˜äº‹ã«ãªã‚Šã¾ã™ã€‚
é–“é•ã£ãŸéƒ¨åˆ†ãªã©ã‚‚ã‚ã‚‹ã‹ã¨æ€ã„ã¾ã™ãŒã€ãã®éš›ã¯ã‚³ãƒ¡ãƒ³ãƒˆãªã©ã§æ•™ãˆã¦ãã ã•ã„ã€‚
:::

ä»Šå›ä½¿ç”¨ã™ã‚‹ã€**DeCipher**ã€ã®ãƒªãƒ³ã‚¯ã¯ä»¥ä¸‹ã«ãªã‚Šã¾ã™ã€‚

https://app.bunzz.dev/decipher/chains/1/addresses/0x16d4f26c15f3658ec65b1126ff27dd3df2a2996b

# æ¦‚è¦

**UniswapV2Migrator**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€Ethereumãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ä¸Šã«æ§‹ç¯‰ã•ã‚ŒãŸåˆ†æ•£å‹å–å¼•æ‰€ï¼ˆDEXï¼‰ã§ã‚ã‚‹**Uniswap**ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®é‡è¦ãªã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã§ã™ã€‚
ã“ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€**UniswapV1**ã‹ã‚‰**UniswapV2**ã¸ã®æµå‹•æ€§ã®ç§»è¡Œã‚’ã‚¹ãƒ ãƒ¼ã‚ºã‹ã¤åŠ¹ç‡çš„ã«è¡Œã†ãŸã‚ã«è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚

## ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ç›®çš„
**UniswapV2Migrator**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ä¸»ãªç›®çš„ã¯ã€æµå‹•æ€§ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ãŒ**UniswapV1**ã‹ã‚‰**UniswapV2**ã¸ã®æµå‹•æ€§ã‚’ã‚·ãƒ¼ãƒ ãƒ¬ã‚¹ã‹ã¤åŠ¹ç‡çš„ã«ç§»è¡Œã™ã‚‹æ‰‹æ®µã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã™ã€‚
ã“ã®ç§»è¡Œã¯ã€**Uniswap**ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³1ã‹ã‚‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³2ã¸ã®ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã«ä¼´ã„ã€ã„ãã¤ã‹ã®æ–°æ©Ÿèƒ½ã¨æ”¹å–„ãŒå°å…¥ã•ã‚ŒãŸãŸã‚å¿…è¦ã¨ã•ã‚Œã¦ã„ã¾ã™ã€‚

ç§»è¡Œãƒ—ãƒ­ã‚»ã‚¹ã¯ã€V1å–å¼•æ‰€ã‹ã‚‰æµå‹•æ€§ã‚’å–ã‚Šå‡ºã—ã€ãã‚Œã‚’V2å–å¼•æ‰€ã«è¿½åŠ ã™ã‚‹ã“ã¨ã‚’å«ã¿ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€æµå‹•æ€§ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã¯æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã®åŒã˜å‰²åˆã‚’ä¿æŒã—ã€ãƒ—ãƒ­ã‚»ã‚¹ä¸­ã«è³‡é‡‘ã‚’å¤±ã†ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

## ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®è²¬ä»»
**UniswapV2Migrator**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«ã¯ã„ãã¤ã‹ã®é‡è¦ãªè²¬ä»»ãŒã‚ã‚Šã¾ã™ã€‚

### Uniswap V1ãŠã‚ˆã³V2ã¨ã®é€£æº
ã“ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€**Uniswap**ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®V1ãŠã‚ˆã³V2ã®ä¸¡æ–¹ã¨é€£æºã—ã¾ã™ã€‚
ç‰¹å®šã®ãƒˆãƒ¼ã‚¯ãƒ³ã®å–å¼•æ‰€ã‚’V1ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‹ã‚‰å–å¾—ã—ã€V2ãƒ«ãƒ¼ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã—ã¦V2å–å¼•æ‰€ã«æµå‹•æ€§ã‚’è¿½åŠ ã—ã¾ã™ã€‚

### æµå‹•æ€§ã®ç§»å‹•
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€V1å–å¼•æ‰€ã‹ã‚‰V2å–å¼•æ‰€ã¸ã®æµå‹•æ€§ã®ç§»å‹•ã‚’å‡¦ç†ã—ã¾ã™ã€‚
ã“ã‚Œã«ã¯ã€V1å–å¼•æ‰€ã‹ã‚‰æµå‹•æ€§ã‚’å–ã‚Šå‡ºã—ã€ãã‚Œã‚’V2å–å¼•æ‰€ã«è¿½åŠ ã™ã‚‹ä½œæ¥­ãŒå«ã¾ã‚Œã¾ã™ã€‚

### å®‰å…¨ãªç§»è¡Œã®ç¢ºä¿
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€ç§»è¡Œãƒ—ãƒ­ã‚»ã‚¹ãŒå®‰å…¨ã§ã‚»ã‚­ãƒ¥ã‚¢ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã™ã€‚
V1å–å¼•æ‰€ã‹ã‚‰ã®æµå‹•æ€§ã®ç§»å‹•ãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€`safeApprove`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦V2ãƒ«ãƒ¼ã‚¿ãƒ¼ã«ãƒˆãƒ¼ã‚¯ãƒ³ã®ä½¿ç”¨è¨±å¯ã‚’ã‚»ã‚­ãƒ¥ã‚¢ã«ä»˜ä¸ã—ã¾ã™ã€‚

### ETHã®å‡¦ç†
ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«ã¯ã€**ETH**ã®å—ã‘å–ã‚Šã‚’è¨±å¯ã™ã‚‹`receive`é–¢æ•°ãŒã‚ã‚Šã¾ã™ã€‚
ã“ã‚Œã¯ã€ç§»è¡Œãƒ—ãƒ­ã‚»ã‚¹ãŒãƒˆãƒ¼ã‚¯ãƒ³ã‚’**ETH**ã«ã‚¹ãƒ¯ãƒƒãƒ—ã—ã€ãã‚Œã‚’V2å–å¼•æ‰€ã«æµå‹•æ€§ã‚’è¿½åŠ ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã™ã‚‹ãŸã‚å¿…è¦ã§ã™ã€‚

ã¾ã¨ã‚ã‚‹ã¨ã€**UniswapV2Migrator**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€**Uniswap**ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«ãŠã„ã¦V1ã‹ã‚‰V2ã¸ã®æµå‹•æ€§ã®ç§»è¡Œã‚’å††æ»‘ã«ã‚µãƒãƒ¼ãƒˆã™ã‚‹é‡è¦ãªå½¹å‰²ã‚’æœãŸã—ã¦ã„ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€ç§»è¡Œãƒ—ãƒ­ã‚»ã‚¹ãŒå®‰å…¨ã§ã‚»ã‚­ãƒ¥ã‚¢ã§ã‚ã‚Šã€**Uniswap**ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ ã®ã‚¤ãƒ³ãƒ†ã‚°ãƒªãƒ†ã‚£ãŒç¶­æŒã•ã‚Œã¦ã„ã¾ã™ã€‚

# ä½¿ã„æ–¹

**UniswapV2Migrator**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€**UniswapV1**ã‹ã‚‰**UniswapV2**ã¸ã®æµå‹•æ€§ã®ç§»è¡Œã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«è¨­è¨ˆã•ã‚Œã¾ã—ãŸã€‚
ã“ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€æ›´æ–°ã•ã‚ŒãŸãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«æµå‹•æ€§ã‚’ç§»å‹•ã•ã›ãŸã„æµå‹•æ€§ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã«ã‚ˆã£ã¦ä¸»ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

ä»¥ä¸‹ã¯ã€**UniswapV2Migrator**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ä½¿ç”¨ã™ã‚‹æ‰‹é †ã§ã™ã€‚

### 1. ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ãƒ‡ãƒ—ãƒ­ã‚¤
æœ€åˆã®ã‚¹ãƒ†ãƒƒãƒ—ã¯ã€**UniswapV2Migrator**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’Ethereumãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹ã“ã¨ã§ã™ã€‚
ã“ã‚Œã«ã¯ã€**UniswapV1**ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã¨**UniswapV2**ãƒ«ãƒ¼ã‚¿ãƒ¼ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿å¼•æ•°ã¨ã—ã¦å¿…è¦ã§ã™ã€‚

### 2. ç§»è¡Œã®æº–å‚™
`migrate`é–¢æ•°ã‚’å‘¼ã³å‡ºã™å‰ã«ã€æµå‹•æ€§ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã¯**UniswapV1**å–å¼•æ‰€ã‹ã‚‰ã®æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã®ç§»å‹•ã‚’**UniswapV2Migrator**ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«æ‰¿èªã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

### 3. Migrateé–¢æ•°ã®å‘¼ã³å‡ºã—
æµå‹•æ€§ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ã¯ã€`migrate`é–¢æ•°ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚
ã“ã®é–¢æ•°ã«ã¯ã€ä»¥ä¸‹ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå¿…è¦ã§ã™ã€‚

- `token`
	- æµå‹•æ€§ãƒšã‚¢ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `amountTokenMin`
	- æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã«è¿½åŠ ã•ã‚Œã‚‹ã¹ããƒˆãƒ¼ã‚¯ãƒ³ã®æœ€å°é‡ã€‚
- `amountETHMin`
	- æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã«è¿½åŠ ã•ã‚Œã‚‹ã¹ãETHã®æœ€å°é‡ã€‚
- `to`
	- æ–°ã—ã„æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ãŒé€ã‚‰ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `deadline`
	- ç§»è¡ŒãŒå®Œäº†ã™ã‚‹å¿…è¦ãŒã‚ã‚‹æ™‚åˆ»ã€‚

### 4. ç§»è¡Œãƒ—ãƒ­ã‚»ã‚¹
`migrate`é–¢æ•°ã¯ã€ä»¥ä¸‹ã®æ‰‹é †ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

- å‘¼ã³å‡ºã—å…ƒãŒ**UniswapV1**å–å¼•æ‰€ã«æŒã£ã¦ã„ã‚‹æµå‹•æ€§ã®é‡ã‚’å–å¾—ã—ã¾ã™ã€‚
- ã“ã®æµå‹•æ€§ã‚’è‡ªèº«ã«é€ã‚Šã¾ã™ã€‚
- **UniswapV1**å–å¼•æ‰€ã‹ã‚‰æµå‹•æ€§ã‚’å–ã‚Šå‡ºã—ã€ãã®ä»£ã‚ã‚Šã«åŸºç¤ã¨ãªã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚
- **UniswapV2**ãƒ«ãƒ¼ã‚¿ãƒ¼ãŒã“ã‚Œã‚‰ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’æ‰¿èªã—ã¾ã™ã€‚
- ãƒˆãƒ¼ã‚¯ãƒ³ã¨**ETH**ã‚’**UniswapV2**å–å¼•æ‰€ã«è¿½åŠ ã—ã€ä»£ã‚ã‚Šã«æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚

### 5. æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã®å—ã‘å–ã‚Š
ç§»è¡Œãƒ—ãƒ­ã‚»ã‚¹ãŒå®Œäº†ã™ã‚‹ã¨ã€æ–°ã—ã„æµå‹•æ€§ãƒˆãƒ¼ã‚¯ãƒ³ã¯`migrate`é–¢æ•°ã®å‘¼ã³å‡ºã—ã§æŒ‡å®šã—ãŸ`to`ã‚¢ãƒ‰ãƒ¬ã‚¹ã«é€ã‚‰ã‚Œã¾ã™ã€‚

æ³¨æ„ç‚¹ã¨ã—ã¦ã€ç§»è¡Œãƒ—ãƒ­ã‚»ã‚¹ã¯è¤‡æ•°ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å¿…è¦ã¨ã—ã€ã‚¬ã‚¹æ–™é‡‘ã‚’ã‚«ãƒãƒ¼ã™ã‚‹ãŸã‚ã«ååˆ†ãªETHãŒå¿…è¦ã§ã™ã€‚
ã¾ãŸã€ç§»è¡Œãƒ—ãƒ­ã‚»ã‚¹ã¯å–ã‚Šæ¶ˆã™ã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚
ä¸€æ—¦æµå‹•æ€§ãŒ**UniswapV2**ã«ç§»è¡Œã•ã‚Œã‚‹ã¨ã€**UniswapV1**ã«æˆ»ã™ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

## _factoryV1

**UniswapV1**ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚
ã“ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ã€**UniswapV1**ã®å–å¼•æ‰€ã‚’ä½œæˆã—ç®¡ç†ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
**UniswapV1**ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€ç•°ãªã‚‹ãƒˆãƒ¼ã‚¯ãƒ³é–“ã®æµå‹•æ€§ãƒ—ãƒ¼ãƒ«ã‚’ä½œæˆã—ã€å–å¼•æ‰€ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã™ã‚‹éš›ã«ä½¿ç”¨ã•ã‚Œã‚‹é‡è¦ãªå½¹å‰²ã‚’æœãŸã—ã¾ã™ã€‚

## _router

**UniswapV2**ãƒ«ãƒ¼ã‚¿ãƒ¼ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™ã€‚
ã“ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ã€**UniswapV2**ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ä¸Šã§ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¹ãƒ¯ãƒƒãƒ—ã‚„æµå‹•æ€§ã®æä¾›ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
**UniswapV2**ãƒ«ãƒ¼ã‚¿ãƒ¼ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¯ã€ãƒˆãƒ¼ã‚¯ãƒ³é–“ã®ã‚¹ãƒ¯ãƒƒãƒ—å–å¼•ã‚’åŠ¹ç‡çš„ã«å‡¦ç†ã—ã€æµå‹•æ€§ã‚’æä¾›ã™ã‚‹ãŸã‚ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹éš›ã«é‡è¦ãªæ©Ÿèƒ½ã‚’æœãŸã—ã¾ã™ã€‚

# é–¢æ•°

## WRITE

### migrate

**UniswapV1**ã‹ã‚‰**UniswapV2**ã«æµå‹•æ€§ã‚’ç§»è¡Œã™ã‚‹é–¢æ•°ã€‚

**å¼•æ•°**

- `token`
	- ç§»è¡Œã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `amountTokenMin`
	- ç§»è¡Œæ™‚ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå—ã‘å–ã‚ŠãŸã„æœ€å°é‡ã®ãƒˆãƒ¼ã‚¯ãƒ³ã€‚
- `amountETHMin`
	- ç§»è¡Œæ™‚ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå—ã‘å–ã‚ŠãŸã„æœ€å°é‡ã®ETHã€‚
- `to`
	- ç§»è¡Œã•ã‚ŒãŸæµå‹•æ€§ãŒé€ã‚‰ã‚Œã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã€‚
- `deadline`
	- ç§»è¡Œæ“ä½œãŒè¡Œã‚ã‚Œã‚‹æœŸé™ã€‚

ã“ã®é–¢æ•°ã¯ã€æœ€åˆã«æŒ‡å®šã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã«å¯¾ã™ã‚‹**UniswapV1**å–å¼•æ‰€ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’`factoryV1.getExchange`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦å–å¾—ã—ã¾ã™ã€‚
æ¬¡ã«ã€é–¢æ•°ã¯å‘¼ã³å‡ºã—å…ƒã®**UniswapV1**å–å¼•æ‰€ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®æ®‹é«˜ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚

ãã®å¾Œã€**UniswapV1**å–å¼•æ‰€ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‹ã‚‰å‘¼ã³å‡ºã—å…ƒã®æµå‹•æ€§ã‚’ç¾åœ¨ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã«`transferFrom`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ç§»å‹•ã—ã¾ã™ã€‚

ãã®å¾Œã€`removeLiquidity`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦**UniswapV1**å–å¼•æ‰€ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‹ã‚‰æµå‹•æ€§ã‚’å–ã‚Šå‡ºã—ã¾ã™ã€‚

`safeApprove`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦`amountTokenV1`ãƒˆãƒ¼ã‚¯ãƒ³ã®**UniswapV2**ãƒ«ãƒ¼ã‚¿ãƒ¼ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã¸ã®é€é‡‘ã‚’æ‰¿èªã—ã¾ã™ã€‚

æ¬¡ã«ã€é–¢æ•°ã¯ãƒ«ãƒ¼ã‚¿ãƒ¼ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã®`addLiquidityETH`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦**UniswapV2**ã«æµå‹•æ€§ã‚’è¿½åŠ ã—ã¾ã™ã€‚
`amountETHV1`**ETH**ãŒæµå‹•æ€§ã®è¿½åŠ ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

ã‚‚ã—`amountTokenV1`ãŒ`amountTokenV2`ã‚ˆã‚Šã‚‚å¤§ãã„å ´åˆã€é–¢æ•°ã¯`safeApprove`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ãƒˆãƒ¼ã‚¯ãƒ³ã®æ‰¿èªã‚’`0`ã«ãƒªã‚»ãƒƒãƒˆã—ã€`safeTransfer`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ä½™å‰°ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å‘¼ã³å‡ºã—å…ƒã«é€é‡‘ã—ã¾ã™ã€‚

ã‚‚ã—`amountETHV1`ãŒ`amountETHV2`ã‚ˆã‚Šã‚‚å¤§ãã„å ´åˆã€é–¢æ•°ã¯`safeTransferETH`é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ä½™å‰°ã®**ETH**ã‚’å‘¼ã³å‡ºã—å…ƒã«é€é‡‘ã—ã¾ã™ã€‚

ã“ã®ã‚ˆã†ã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒ**UniswapV1**ã‹ã‚‰**UniswapV2**ã«æµå‹•æ€§ã‚’ç§»è¡Œã—ã€**UniswapV2**ãŒæä¾›ã™ã‚‹æ©Ÿèƒ½ã¨åˆ©ç‚¹ã‚’æ´»ç”¨ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚

:::message
`deadline`ã¯ã€æµå‹•æ€§ã®ç§»è¡Œæ“ä½œãŒè¡Œã‚ã‚Œã‚‹æœŸé™ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ã™ã€‚
ã“ã®æœŸé™ã¯ã€å–å¼•ã®å®Ÿè¡ŒãŒã‚ã‚‹ä¸€å®šã®æœŸé–“å†…ã«å®Œäº†ã™ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚
æŒ‡å®šã•ã‚ŒãŸæœŸé™ï¼ˆUnixã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼‰ã¾ã§ã«å‡¦ç†ãŒå®Œäº†ã—ãªã„å ´åˆã€é–¢æ•°ã¯å®Ÿè¡Œã•ã‚Œãšã«ã‚¨ãƒ©ãƒ¼ãŒè¿”ã•ã‚Œã¾ã™ã€‚ã“ã®ä»•çµ„ã¿ã«ã‚ˆã‚Šã€æµå‹•æ€§ã®ç§»è¡Œæ“ä½œãŒã‚ã‚‹ç¨‹åº¦ã®æ™‚é–“å†…ã«ç¢ºå®Ÿã«å®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¾ã™ã€‚

ãŸã¨ãˆã°ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€Œ`migrate`ã€é–¢æ•°ã‚’å‘¼ã³å‡ºã™éš›ã«ã€æœŸé™ã‚’1æ™‚é–“å¾Œã®Unixã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã¨ã—ã¦æŒ‡å®šã—ãŸå ´åˆã€1æ™‚é–“ä»¥å†…ã«ç§»è¡Œæ“ä½œãŒå®Œäº†ã—ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€ç§»è¡Œæ“ä½œãŒé©åˆ‡ãªæ™‚é–“å†…ã«å®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ãŒç¢ºèªã•ã‚Œã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã®ç¢ºå®šæ€§ãŒå‘ä¸Šã—ã¾ã™ã€‚
:::

# ã‚¤ãƒ™ãƒ³ãƒˆ

ç‰¹ã«ãªã—ã€‚

# ã‚³ãƒ¼ãƒ‰

## IUniswapV2Migrator

:::details IUniswapV2Migrator
```solidity
pragma solidity =0.6.6;

interface IUniswapV2Migrator {
    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external;
}
```
:::

## IUniswapV1Factory

:::details IUniswapV1Factory
```solidity
interface IUniswapV1Factory {
    function getExchange(address) external view returns (address);
}
```
:::

## IUniswapV1Exchange

:::details IUniswapV1Exchange
```solidity
interface IUniswapV1Exchange {
    function balanceOf(address owner) external view returns (uint);
    function transferFrom(address from, address to, uint value) external returns (bool);
    function removeLiquidity(uint, uint, uint, uint) external returns (uint, uint);
    function tokenToEthSwapInput(uint, uint, uint) external returns (uint);
    function ethToTokenSwapInput(uint, uint) external payable returns (uint);
}
```
:::

## IUniswapV2Router01

:::details IUniswapV2Router01
```solidity
interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}
```
:::

## IERC20

:::details IERC20
```solidity
interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
}
```
:::

## UniswapV2Migrator

:::details UniswapV2Migrator
```solidity
contract UniswapV2Migrator is IUniswapV2Migrator {
    IUniswapV1Factory immutable factoryV1;
    IUniswapV2Router01 immutable router;

    constructor(address _factoryV1, address _router) public {
        factoryV1 = IUniswapV1Factory(_factoryV1);
        router = IUniswapV2Router01(_router);
    }

    // needs to accept ETH from any v1 exchange and the router. ideally this could be enforced, as in the router,
    // but it's not possible because it requires a call to the v1 factory, which takes too much gas
    receive() external payable {}

    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline)
        external
        override
    {
        IUniswapV1Exchange exchangeV1 = IUniswapV1Exchange(factoryV1.getExchange(token));
        uint liquidityV1 = exchangeV1.balanceOf(msg.sender);
        require(exchangeV1.transferFrom(msg.sender, address(this), liquidityV1), 'TRANSFER_FROM_FAILED');
        (uint amountETHV1, uint amountTokenV1) = exchangeV1.removeLiquidity(liquidityV1, 1, 1, uint(-1));
        TransferHelper.safeApprove(token, address(router), amountTokenV1);
        (uint amountTokenV2, uint amountETHV2,) = router.addLiquidityETH{value: amountETHV1}(
            token,
            amountTokenV1,
            amountTokenMin,
            amountETHMin,
            to,
            deadline
        );
        if (amountTokenV1 > amountTokenV2) {
            TransferHelper.safeApprove(token, address(router), 0); // be a good blockchain citizen, reset allowance to 0
            TransferHelper.safeTransfer(token, msg.sender, amountTokenV1 - amountTokenV2);
        } else if (amountETHV1 > amountETHV2) {
            // addLiquidityETH guarantees that all of amountETHV1 or amountTokenV1 will be used, hence this else is safe
            TransferHelper.safeTransferETH(msg.sender, amountETHV1 - amountETHV2);
        }
    }
}
```
:::

## TransferHelper

:::details TransferHelper
```solidity
pragma solidity =0.6.6;

interface IUniswapV2Migrator {
    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external;
}

interface IUniswapV1Factory {
    function getExchange(address) external view returns (address);
}

interface IUniswapV1Exchange {
    function balanceOf(address owner) external view returns (uint);
    function transferFrom(address from, address to, uint value) external returns (bool);
    function removeLiquidity(uint, uint, uint, uint) external returns (uint, uint);
    function tokenToEthSwapInput(uint, uint, uint) external returns (uint);
    function ethToTokenSwapInput(uint, uint) external payable returns (uint);
}

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);
}

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint value);
    event Transfer(address indexed from, address indexed to, uint value);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint);
    function balanceOf(address owner) external view returns (uint);
    function allowance(address owner, address spender) external view returns (uint);

    function approve(address spender, uint value) external returns (bool);
    function transfer(address to, uint value) external returns (bool);
    function transferFrom(address from, address to, uint value) external returns (bool);
}

contract UniswapV2Migrator is IUniswapV2Migrator {
    IUniswapV1Factory immutable factoryV1;
    IUniswapV2Router01 immutable router;

    constructor(address _factoryV1, address _router) public {
        factoryV1 = IUniswapV1Factory(_factoryV1);
        router = IUniswapV2Router01(_router);
    }

    // needs to accept ETH from any v1 exchange and the router. ideally this could be enforced, as in the router,
    // but it's not possible because it requires a call to the v1 factory, which takes too much gas
    receive() external payable {}

    function migrate(address token, uint amountTokenMin, uint amountETHMin, address to, uint deadline)
        external
        override
    {
        IUniswapV1Exchange exchangeV1 = IUniswapV1Exchange(factoryV1.getExchange(token));
        uint liquidityV1 = exchangeV1.balanceOf(msg.sender);
        require(exchangeV1.transferFrom(msg.sender, address(this), liquidityV1), 'TRANSFER_FROM_FAILED');
        (uint amountETHV1, uint amountTokenV1) = exchangeV1.removeLiquidity(liquidityV1, 1, 1, uint(-1));
        TransferHelper.safeApprove(token, address(router), amountTokenV1);
        (uint amountTokenV2, uint amountETHV2,) = router.addLiquidityETH{value: amountETHV1}(
            token,
            amountTokenV1,
            amountTokenMin,
            amountETHMin,
            to,
            deadline
        );
        if (amountTokenV1 > amountTokenV2) {
            TransferHelper.safeApprove(token, address(router), 0); // be a good blockchain citizen, reset allowance to 0
            TransferHelper.safeTransfer(token, msg.sender, amountTokenV1 - amountTokenV2);
        } else if (amountETHV1 > amountETHV2) {
            // addLiquidityETH guarantees that all of amountETHV1 or amountTokenV1 will be used, hence this else is safe
            TransferHelper.safeTransferETH(msg.sender, amountETHV1 - amountETHV2);
        }
    }
}

// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false
library TransferHelper {
    function safeApprove(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('approve(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');
    }

    function safeTransfer(address token, address to, uint value) internal {
        // bytes4(keccak256(bytes('transfer(address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');
    }

    function safeTransferFrom(address token, address from, address to, uint value) internal {
        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');
    }

    function safeTransferETH(address to, uint value) internal {
        (bool success,) = to.call{value:value}(new bytes(0));
        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');
    }
}
```
:::

# æœ€å¾Œã«

ä»Šå›ã®è¨˜äº‹ã§ã¯ã€Bunzzã®æ–°æ©Ÿèƒ½ã€**DeCipher**ã€ã‚’ä½¿ç”¨ã—ã¦ã€**UniswapV2**ã®ã€Œ**UniswapV2Migrator**ã€ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’è¦‹ã¦ãã¾ã—ãŸã€‚
ã„ã‹ãŒã ã£ãŸã§ã—ã‚‡ã†ã‹ï¼Ÿ
ä»Šå¾Œã‚‚ç‰¹å®šã®NFTã‚„ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’ãƒ”ãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã¦ã¾ã¨ã‚ã¦è¡ŒããŸã„ã¨æ€ã„ã¾ã™ã€‚

æ™®æ®µã¯ãƒ–ãƒ­ã‚°ã‚„Qiitaã§ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã‚„AIã«é–¢ã™ã‚‹è¨˜äº‹ã‚’æŒ™ã’ã¦ã„ã‚‹ã®ã§ã€ã‚ˆã‘ã‚Œã°è¦‹ã¦ã„ã£ã¦ãã ã•ã„ï¼

https://chaldene.net/

https://qiita.com/cardene

